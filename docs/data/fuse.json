{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title"},{"path":["body"],"id":"body","weight":1,"src":"body"}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"( Φ w Φ )","n":0.447},"1":{"v":"\nDendron 官網: https://wiki.dendron.so/\n\n<!-- ![[首次使用 Dendron 紀錄|drops.2021.1226-first-day#使用-dendron-紀錄:#*]] -->\n<!-- <div class=\"portal-container\">\n<div class=\"portal-head\">\n<div class=\"portal-backlink\">\n<div class=\"portal-title\">From <span class=\"portal-text-title\">1226 使用 Dendron 紀錄</span></div>\n<a href=\"/notes/DTeYpEuPv3KIHugUyqZPu\" class=\"portal-arrow\">Go to text <span class=\"right-arrow\">→</span></a>\n</div>\n</div>\n<div id=\"portal-parent-anchor\" class=\"portal-parent\" markdown=\"1\">\n<div class=\"portal-parent-fader-top\"></div>\n<div class=\"portal-parent-fader-bottom\"></div><h2 id=\"使用-dendron-紀錄\"><a aria-hidden=\"true\" class=\"anchor-heading\" href=\"#使用-dendron-紀錄\"><svg aria-hidden=\"true\" viewBox=\"0 0 16 16\"><use xlink:href=\"#svg-link\"></use></svg></a>使用 Dendron 紀錄</h2>\n</div></div> -->\n","n":0.156}}},{"i":2,"$":{"0":{"v":"Tags","n":1}}},{"i":3,"$":{"0":{"v":"PROG","n":1}}},{"i":4,"$":{"0":{"v":"TypeScript","n":1}}},{"i":5,"$":{"0":{"v":"Server","n":1}}},{"i":6,"$":{"0":{"v":"OS","n":1}}},{"i":7,"$":{"0":{"v":"Nx","n":1}}},{"i":8,"$":{"0":{"v":"JavaScript","n":1}}},{"i":9,"$":{"0":{"v":"HTML","n":1}}},{"i":10,"$":{"0":{"v":"Dendron","n":1}}},{"i":11,"$":{"0":{"v":"CSS","n":1}}},{"i":12,"$":{"0":{"v":"C#","n":1}}},{"i":13,"$":{"0":{"v":"Angular","n":1}}},{"i":14,"$":{"0":{"v":"Android","n":1}}},{"i":15,"$":{"0":{"v":"Flutter","n":1}}},{"i":16,"$":{"0":{"v":"Android","n":1}}},{"i":17,"$":{"0":{"v":"Other","n":1}}},{"i":18,"$":{"0":{"v":"About","n":1},"1":{"v":"\n嗨，我是 naomi。 這個部落格是用 Dendron 官方提供的樣板製作而成的。\n\n紀錄工作上工作下的程式相關筆記。 關於筆記內容:\n\n如果有時間會盡量翻譯原文，翻譯的地方會附上原文，因為自己不是專業的翻譯員，翻得不妥還有原文在。\n基本上會附上參考與引用的出處。\n\n<!-- [背景音樂✨](https://www.youtube.com/watch?v=GTlQhMRHXIg) -->\n\n<div id=\"wrap\">\n    <div id=\"player\"></div>\n    <div id=\"btn-area\">\n        <button id=\"btn-stop\" onclick=\"stopVideo()\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path fill-rule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z\" clip-rule=\"evenodd\"></path>\n            </svg>\n        </button>\n        <button id=\"btn-play\" onclick=\"playMyVedio()\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path fill-rule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z\" clip-rule=\"evenodd\"></path>\n            </svg>\n        </button>\n        <button id=\"btn-pause\" onclick=\"pauseVideo()\">\n        <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n            <path fill-rule=\"evenodd\" d=\"M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z\" clip-rule=\"evenodd\"></path>\n        </svg>\n        </button>\n        <button id=\"btn-unMute\" onclick=\"unMute()\" style=\"display: none;\">\n        <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n            <path fill-rule=\"evenodd\" d=\"M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM12.293 7.293a1 1 0 011.414 0L15 8.586l1.293-1.293a1 1 0 111.414 1.414L16.414 10l1.293 1.293a1 1 0 01-1.414 1.414L15 11.414l-1.293 1.293a1 1 0 01-1.414-1.414L13.586 10l-1.293-1.293a1 1 0 010-1.414z\" clip-rule=\"evenodd\"></path>\n        </svg>\n        </button>\n        <button id=\"btn-mute\" onclick=\"mute()\" style=\"display: flex;\">\n        <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n            <path fill-rule=\"evenodd\" d=\"M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM14.657 2.929a1 1 0 011.414 0A9.972 9.972 0 0119 10a9.972 9.972 0 01-2.929 7.071 1 1 0 01-1.414-1.414A7.971 7.971 0 0017 10c0-2.21-.894-4.208-2.343-5.657a1 1 0 010-1.414zm-2.829 2.828a1 1 0 011.415 0A5.983 5.983 0 0115 10a5.984 5.984 0 01-1.757 4.243 1 1 0 01-1.415-1.415A3.984 3.984 0 0013 10a3.983 3.983 0 00-1.172-2.828 1 1 0 010-1.415z\" clip-rule=\"evenodd\"></path>\n        </svg>\n        </button>\n    </div>\n    <div id=\"bar-wrap\">\n        <div id=\"bar\" style=\"width: 0%;\"></div>\n    </div>\n</div>\n\n> \"I drink 14 pints of mouthwash rations per week. At the rate... I think I'm\n> going to poison myself to death... before I ever get to see the world again,\n> which makes me feel... very sad. > I gotta change my program. I gotta go in a\n> new direction. Anything I can do to keep my hands busy, I'm gonna do.\n> Otherwise... I think maybe it's gonna be a suicide. And that's why I signed up\n> for clay pottery and basket weaving. My name is Moses.\" ——《The French\n> Dispatch》\n","n":0.051}}},{"i":19,"$":{"0":{"v":"Drops","n":1}}},{"i":20,"$":{"0":{"v":"2023","n":1}}},{"i":21,"$":{"0":{"v":"0304 [unbuntu&windows]進入 BIOS","n":0.577},"1":{"v":"\n快速開機真的有夠難按到 `Del`，以下是在系統裡重開機進入 BIOS 的指令。\n\n## Ubuntu 22.04.2 LTS\n\n```bash\nsudo systemctl reboot --firmware-setup\n```\n\n用來重新啟動系統並進入固件設置模式（也稱為 BIOS 或 UEFI 設置模式）的命令。\n\n它由以下三部分組成：\n\n- `sudo`：這個關鍵字表示需要使用超級用戶權限運行命令。請注意，在運行這個命令之前，系統會要求您輸入您的密碼。\n\n- `systemctl reboot`：這部分命令用來重新啟動系統。它會將系統關閉，然後重新啟動系統。\n\n  - `systemctl` 是一個用於管理 `Systemd` 系統和服務的命令行工具。`Systemd` 是一個用於管理 Linux 系統的系統和服務的守護進程，它負責管理系統的各種組件和進程，例如初始化進程、網絡服務、日誌記錄、進程控制等。\n\n  `systemctl` 命令可以用來**啟動、停止、重啟和查詢系統中運行的 Systemd 服務**。使用 systemctl 命令還可以查看服務的運行狀態、啟動時間、最後一次啟動的結果等詳細信息。在 Linux 系統管理中，systemctl 是一個非常有用的命令行工具，它可以幫助管理員更好地了解系統的運行狀態和服務的運行情況。\n\n  以下是一些常用的 `systemctl` 命令：\n\n  `systemctl start service`：啟動一個服務\n  `systemctl stop service`：停止一個服務\n  `systemctl restart service`：重啟一個服務\n  `systemctl status service`：查詢一個服務的狀態\n  `systemctl enable service`：將一個服務設置為開機啟動\n  `systemctl disable service`：將一個服務設置為不開機啟動\n  需要注意的是，systemctl 命令需要以超級用戶權限運行，可以使用 sudo 命令來運行。\n\n- `--firmware-setup`：這個選項指示系統在重新啟動時進入固件設置模式。當系統進入固件設置模式時，您可以更改許多與硬件設置有關的選項，例如啟動順序、CPU 頻率、記憶體時序等等。在固件設置模式下，您可以使用鍵盤和滑鼠進行選擇和更改。\n\n### 關掉 GRUB 挑選畫面\n\n- 打開檔案 `sudo gedit /etc/grub.d/30_os-prober`\n\n- 並修改成 `quick_boot=\"0\"`\n\n![](/assets/images/2023-03-13-01-10-22.png)\n\n> 參考 [How to Hide Grub Boot Menu in Ubuntu 20.04, 21.10 (Updated)](https://ubuntuhandbook.org/index.php/2020/06/hide-grub-boot-menu-ubuntu-20-04-lts/)\n\n## Windows 11\n\n```cmd\nshutdown /r /fw /t 0\n```\n\n這是一個使用 `shutdown.exe` 的命令，它告訴 Windows 在關閉電腦之前等待 0 秒（立即關閉），\n然後重新啟動並進入 UEFI 固件設置。\n\n這個命令中的參數含義如下：\n\n- `/r`：這個選項表示 Windows 將重啟電腦，而不是直接關閉電腦。\n- `/fw`：這個選項表示 Windows 將在重啟後進入 UEFI 固件設置。進入 UEFI 固件設置後，您可以更改許多 BIOS/UEFI 相關的設置。\n- `/t 0`：這個選項表示 Windows 不需要等待即可關閉電腦。如果您希望 Windows 等待一段時間後關閉電腦，可以將 /t 參數後面的數字更改為所需的等待時間（以秒為單位）。\n\n總之，`shutdown /r /fw /t 0` 命令會將 Windows 關閉，立即重新啟動，並進入 UEFI 固件設置。如果您希望在進入 UEFI 固件設置之前有一些時間來保存任何未保存的工作，可以將 `/t` 參數後面的數字更改為所需的等待時間。\n","n":0.088}}},{"i":22,"$":{"0":{"v":"0226 圖片 RWD 與不變形和壓縮","n":0.5},"1":{"v":"\n## 1. 圖片 RWD 與不變形和壓縮\n\n### 1.1. 在網頁上的圖片格式\n\n- JPEG（.jpg）：這是最常見的圖片格式之一，通常用於照片和圖片，因為它可以壓縮圖像以減小文件大小，同時保持高品質的圖像。JPEG 格式的圖像可以包含 1600 萬個顏色，這使得它成為展示高品質照片的理想格式。\n\n- PNG（.png）：PNG 格式的圖像通常用於圖形和圖像，因為它可以支持透明背景。PNG 格式的圖像不會有品質損失，因此它可以用於需要高品質圖像的場合。\n\n- GIF（.gif）：GIF 格式的圖像通常用於動畫，因為它可以包含多個圖像幀。GIF 格式的圖像可以包含最多 256 種顏色，這使得它不適合展示高品質照片，但非常適合用於簡單的圖形和動畫。\n\n- SVG（.svg）：SVG 格式的圖像是矢量圖形，它們可以縮放到任何大小而不會失去品質。SVG 格式的圖像通常用於圖形和圖像，特別是需要在不同尺寸的屏幕上顯示的場合。\n\n- WebP（.webp）：WebP 格式的圖像是由 Google 開發的一種圖像格式，它可以壓縮圖像以減小文件大小，同時保持高品質的圖像。WebP 格式的圖像通常用於網頁，因為它們可以加快網頁加載速度。\n\n- AVIF（.avif）： 是一種現代的圖像格式，它是基於開放標準的編碼方式，可提供更高的圖像品質和更小的文件大小。AVIF 格式通常用於網頁、移動應用程序和其他需要高質量圖像的應用程序。\n\n## 2. HTML 圖片的載入(像素密度、螢幕寬度、多種格式)\n\n`srcset` 屬於 HTML 中 `<img>` 或 `<source>` 標籤的屬性，可用於指定可替代圖片的多種版本，並讓瀏覽器根據不同的設備和網路環境自動選擇最適合的圖片版本載入。srcset 屬性支援的圖片格式包括 `PNG`、`JPEG`、`WebP`、`AVIF` 等。常見的用法有以下幾種：\n\n### 2.1. HTML `<img>` 和 `<source>` 的屬性\n\n- `srcset`、`sizes` 屬於 HTML 中 `<img>` 或 `<source>` 標籤的屬性。\n\n  - `<img>` 內使用方式：\n\n  ```html\n  <img\n    srcset=\"\n      /img/html/vangogh-sm.jpg 120w,\n      /img/html/vangogh.jpg    193w,\n      /img/html/vangogh-lg.jpg 278w\n    \"\n    sizes=\"(max-width: 710px) 120px,\n              (max-width: 991px) 193px,\n              278px\"\n    loading=\"lazy\"\n  />\n  ```\n\n  > `<img>` 可以設定 `loading=\"lazy\"` 來延遲載入圖片。\n  > 這樣會載入一張圖片，首次載入頁面瀏覽器會根據 `srcset` 判斷要顯示哪張圖，之後用 `sizes` 判斷要顯示哪個尺寸。\n\n  - `<source>` 內使用方式 ：\n\n  ```html\n  <picture>\n    <source\n      srcset=\"\n        /img/html/vangogh-sm.jpg 120w,\n        /img/html/vangogh.jpg    193w,\n        /img/html/vangogh-lg.jpg 278w\n      \"\n      sizes=\"(max-width: 710px) 120px,\n             (max-width: 991px) 193px,\n             278px\"\n    />\n    <img\n      src=\"/img/html/vangogh-lg.jpg\"\n      alt=\"Vincent Van Gogh\"\n    />\n  </picture>\n  ```\n\n  - `srcset` 代表：\n\n    圖片寬度 120w 時用 vangogh-sm.jpg\n\n    圖片寬度 193w 時用 vangogh.jpg\n\n    圖片寬度 278w 時用 vangogh-lg.jpg\n\n  - `sizes` 代表，可以用來設定圖片大小：\n\n    在寬度在 0 到 710px 的螢幕上，圖片寬度為 120px。\n\n    在寬度在 711px 到 991px 的螢幕上，圖片寬度為 193px。\n\n    在寬度為 992px 及以上的螢幕上，圖片寬度為 278px。\n\n使用方式：\n\n- `<tagname srcset=\"URL width(圖片寬度)\">`\n- `<tagname sizes=\"(media-condition) width(圖片寬度)\">`\n\n來源： [HTML srcset Attribute](https://www.dofactory.com/html/srcset)\n\n### 2.2. 指定不同像素密度的圖片版本\n\n```html\n<img\n  srcset=\"\n    image-1x.png 1x,\n    image-2x.png 2x,\n    image-3x.png 3x\n  \"\n  src=\"image-1x.png\"\n  alt=\"...\"\n/>\n```\n\n例如，如果當前設備的像素密度為 2x，則會載入 image-2x.png 這個版本的圖片。\n\nsrcset 中的 1x、2x、3x 等是相對于 DPR（Device Pixel Ratio，設備像素比）而言的，而 DPR 是指設備的物理像素數與邏輯像素數（CSS 像素數）之間的比率。\n\n所以 srcset 的 1x、2x、3x 等可以被視為基於 DPR 的分辨率倍數。\n\n而 PPI 則是指每英寸的像素數量，通常用來描述螢幕或打印品的像素密度。兩者是不同的概念。\n\nDPR 指的是圖片寬度和 `viewport` 寬度之比，計算方式如下：(圖片寬度) / (`viewport` 寬度)\n\n```\norig.jpg：DPR = 600/600 = 1\nwider.jpg：DPR = 1200/600 = 2\nwidest.jpg：DPR = 2000/600 = 3.33\n```\n\n參考自： [Understanding the Device Pixel Ratio](https://tomroth.com.au/dpr/)\n\n![](/assets/images/2023-03-12-23-26-43.png)\n\n> google devtool 可以開啟 DPR (Device Pixel Ratio)，預設為 DPR 2，如果你 srcset 有用 1.5x 但沒 2x，裝置會從預設的往下找最高的圖來用，所以會顯示 1.5x 的那張圖。\n\n圖片網址： [Responsive images - try it](https://googlesamples.github.io/web-fundamentals/fundamentals/design-and-ux/responsive/sizes.html)\n\n參考： [How to simulate pixel ratio to test media queries with Google Chrome or Firefox on Windows? - stackoverflow](https://stackoverflow.com/questions/16382542/how-to-simulate-pixel-ratio-to-test-media-queries-with-google-chrome-or-firefox)\n\n### 2.3. 指定不同螢幕寬度的圖片版本\n\n```html\n<img\n  srcset=\"\n    image-320w.png 320w,\n    image-480w.png 480w,\n    image-640w.png 640w,\n    image-960w.png 960w\n  \"\n  src=\"image-320w.png\"\n  alt=\"...\"\n/>\n```\n\n例如，如果當前設備的螢幕寬度為 500px，則會載入 image-480w.png 這個版本的圖片。\n\n在 `srcset` 中，`w` 是一種描述圖像大小的單位，代表圖像的寬度，`1w = 1px`。\n\n它用來告訴瀏覽器圖像的像素密度，讓瀏覽器可以選擇最適合當前設備的圖像大小。\n\n例如，`320w` 意味著圖像的寬度為 `320 像素`。\n\n以上範例適用於 `width: 100%` 圖片。\n\n### 2.4. 指定多種格式的圖片版本\n\n```html\n<picture>\n  <!-- 有支援的話，會先載入 -->\n  <source\n    srcset=\"\n      /img/my-picture.avif\n    \"\n    type=\"image/avif\"\n  />\n  <!-- 否則次載入 -->\n  <source\n    srcset=\"\n      /img/my-picture.webp\n    \"\n    type=\"image/webp\"\n  />\n  <!-- 以上都不支援，則載入 -->\n  <img\n    src=\"/img/my-picture.jpg\"\n    loading=\"lazy\"\n    alt=\"my-picture\"\n  />\n</picture>\n```\n\n這個圖片使用了 `<picture>` 元素，並在其中嵌套了 `<source>` 和 `<img>` 元素。當瀏覽器加載圖片時，它會首先從 `<source>` 中選擇符合條件的圖像，如果沒有符合條件的，則會載入 `<img>` 中指定的圖片。\n\n參考： [Responsive images - web.dev](https://web.dev/responsive-images/#art-direction-in-responsive-images-with-picture)\n\n## 3. 混用\n\n`w` 和 `x` 可以混用。\n\n```html\n<img\n  alt=\"my awesome image\"\n  src=\"banner.jpeg\"\n  srcset=\"banner-HD.jpeg 2x, banner-phone.jpeg 640w, banner-phone-HD.jpeg 640w 2x\"\n/>\n```\n\n參考自： [High DPI images for variable pixel densities - web.dev](https://web.dev/high-dpi/)\n\n## 4. 圖片解析度? DPI、PPI、LPI?\n\n### 4.1. LPI 和 DPI 通常用來描述印刷品的解析度和清晰度\n\n- DPI (Dot per inch)：為每英吋多少點，DPI 是用來描述數位影像解析度的單位，通常用於電腦顯示器或數位印刷上。\n\n- LPI (Lines per inch)：為每英吋多少印刷網線，業界常提到的網線數、條數就是 LPI，由點構成線為單位。\n\n高階印刷機規格以 2400 DPI 為主， 1200 DPI 低階印刷機及 600 DPI 家用印表機。\n\n它們的關係是：`DPI ≥ 2 x LPI`，也就是說，DPI 至少應該是 LPI 的兩倍才能保證能夠呈現出平滑的圖像。\n\n因此，如果要達到 300 LPI 的效果，至少需要 600 DPI 的打印分辨率。\n\nLPI 是指印刷時網點的線數，描述了印刷品上印刷網點的密度和大小；DPI 是指印刷時打印機頭上的噴墨或雷射打印頭的密度，描述了打印時可打印的最小點的大小。\n\n**無版印刷**可以使用 DPI，例如數位噴墨印刷機或數位直接印刷機都需要指定 DPI 的設定。\n\n**平版印刷**則通常使用 LPI，表示每英吋使用多少線網印刷，以及使用何種角度設定網點的大小。\n\n因此，DPI 和 LPI 雖然都是描述解析度的單位，但是用途和應用場景不同。\n\n![](/assets/images/2023-03-02-21-40-40.png)\n\n> [高英工商自編教材](https://www.kyicvs.khc.edu.tw/images/ckfinder/books1/des03/mobile/index.html#p=47)\n\n![](/assets/images/2023-03-02-21-43-48.png)\n\n> [【印刷概論】01 正修科大](https://modern.csu.edu.tw/wSite/public/Attachment/f1398761171894.pdf)\n\n![](/assets/images/2023-03-02-21-46-54.png)\n\n> 無版印刷不需曬版製版階段。\n\n![](/assets/images/2023-03-02-21-59-44.png)\n\n> [恆成小學堂總複習：網點 / 線數 LPI（Lines Per Inch）](https://www.facebook.com/auspicpaper/posts/pfbid02HxYddX7dg42Z3i5xS5ZvzuYt8osE6ShYbM5yg3bwRgkXz2uz69X8Bved2NnrfK7jl)\n\n### 4.2. PPI 圖像的解析度\n\n- PPI (Pixels per inch)：為每英吋多少像素，通 q 常是指圖像的解析度。假如一個印刷品圖像為 300 PPI，代表其每英寸有 300 像素，PPI 數值越高，檔案越大，螢幕顯示的圖像越精細；相反地 PPI 越低，檔案越小，圖片越不清楚。\n\n螢幕的像素密度可按以下公式計算：\n`像素密度 = (總像素數的平方根) / 對角線尺寸`\n\n27 吋 720P 螢幕 PPI 約為 54.78 PPI。\n27 吋 1080P 螢幕 PPI 約為 82.1 PPI。\n27 吋 4K 螢幕 PPI 約為 163.18 PPI。\n27 吋 8K 螢幕 PPI 約為 326 ppi 左右。 (ChatGPT 計算結果)\n\n關於 PPI 根據 [ios-resolution](https://www.ios-resolution.com/)\n\niphone 最高畫質為 476 PPI，ipad 最高畫質為 326 PPI。\n\n## 5. CSS 設定 DPR 與 DPI media query\n\n在 CSS 中，可以使用媒體查詢（media queries）的方式，根據設備的像素密度（DPR）指定相應的圖像資源。例如：\n\n```css\n@media (-webkit-min-device-pixel-ratio: 2),\n  (min-resolution: 192dpi) {\n  /* 這裡是2x圖片的樣式 */\n  background-image: url(image@2x.png);\n}\n```\n\n> - [resolution - MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/resolution)\n> - [-webkit-device-pixel-rate（非標準盡量別用) - MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/resolution)\n\n在這個例子中，如果設備的像素密度是 2，\n\n或者顯示器的分辨率達到了 192dpi（每英寸點數）以上，就會顯示 image@2x.png。\n\n注意，不同的設備可能使用不同的查詢方式，上面的例子只是其中一種。\n\n## 6. 使用 sharp 來將 svg 轉檔\n\n![](/assets/images/2023-03-12-22-58-31.png)\n\n以圖片轉檔工具 [sharp](https://sharp.pixelplumbing.com/api-constructor) 為例，TIFF 和 PDF 才可以用 `sharp` 設定 DPI。\n\n其他格式如 `avif`、`webp`、`jpeg`、`png` 沒辦法用這個設定，產出來的圖都會是 72 ppi，所以如果是用 `svg` 原始 `320px` 寬的要轉圖給 srcset 2x 用，要設定成產生寬 `640px` 的圖，就可以達到兩倍 PPI `320:640(px) = 1:2(DPR) = 72:144(PPI)` 的效果。(注意： 因為 svg 是向量圖，所以可以這樣無損產生比較大尺寸的圖，若是點陣圖要產新尺寸，只能往下不然會變模糊。)\n\n附註： [可以下載吳哲宇大大用 sharp 寫好的 js 來用](https://github.com/frank890417/image-optimizer)\n\n- 所以可以這樣用 (以下共有三張圖稿，需要各產五種圖檔)：\n\n```html\n<picture>\n  <source\n    srcset=\"\n      /assets/images/tutor/tutor_LG/tutor_LG-1170.avif,\n      /assets/images/tutor/tutor_LG/tutor_LG-1.5x.avif 1.5x\n    \"\n    media=\"(min-width: 1170px)\"\n    type=\"image/avif\"\n  />\n  <source\n    srcset=\"\n      /assets/images/tutor/tutor_LG/tutor_LG-1170.webp,\n      /assets/images/tutor/tutor_LG/tutor_LG-1.5x.webp 1.5x\n    \"\n    media=\"(min-width: 1170px)\"\n    type=\"image/webp\"\n  />\n  <source\n    srcset=\"\n      /assets/images/tutor/tutor_LG/tutor_LG-1170.jpeg\n    \"\n    media=\"(min-width: 1170px)\"\n    type=\"image/jpeg\"\n  />\n  <source\n    srcset=\"\n      /assets/images/tutor/tutor_MD/tutor_MD-768.avif,\n      /assets/images/tutor/tutor_MD/tutor_MD-1.5x.avif 1.5x\n    \"\n    media=\"(min-width: 768px)\"\n    type=\"image/avif\"\n  />\n  <source\n    srcset=\"\n      /assets/images/tutor/tutor_MD/tutor_MD-768.webp,\n      /assets/images/tutor/tutor_MD/tutor_MD-1.5x.webp 1.5x\n    \"\n    media=\"(min-width: 768px)\"\n    type=\"image/webp\"\n  />\n  <source\n    srcset=\"\n      /assets/images/tutor/tutor_MD/tutor_MD-768.jpeg\n    \"\n    media=\"(min-width: 768px)\"\n    type=\"image/jpeg\"\n  />\n  <source\n    srcset=\"\n      /assets/images/tutor/tutor_SM/tutor_SM-320.avif,\n      /assets/images/tutor/tutor_SM/tutor_SM-1.5x.avif 1.5x\n    \"\n    media=\"(min-width: 320px)\"\n    type=\"image/avif\"\n  />\n  <source\n    srcset=\"\n      /assets/images/tutor/tutor_SM/tutor_SM-320.webp,\n      /assets/images/tutor/tutor_SM/tutor_SM-1.5x.webp 1.5x\n    \"\n    media=\"(min-width: 320px)\"\n    type=\"image/webp\"\n  />\n  <source\n    srcset=\"\n      /assets/images/tutor/tutor_SM/tutor_SM-320.jpeg\n    \"\n    media=\"(min-width: 320px)\"\n    type=\"image/jpeg\"\n  />\n  <img\n    alt=\"tutor image\"\n    sizes=\"(max-width: 767px) 320px,\n                (max-width: 1169px) 768px,\n                1170px\"\n    srcset=\"\n      /assets/images/tutor/tutor_SM/tutor_SM-320.jpeg   320w,\n      /assets/images/tutor/tutor_MD/tutor_MD-768.jpeg   768w,\n      /assets/images/tutor/tutor_LG/tutor_LG-1170.jpeg 1170w\n    \"\n    loading=\"lazy\"\n  />\n</picture>\n```\n\n- 圖片用 svg 產生以下尺寸：\n\n![](/assets/images/2023-03-13-00-45-19.png)\n\n## 小結\n\n以後就知道圖片可以跟設計師要 `svg` 轉檔會最方便。\n\n不然就要直接跟對方要最大尺寸的 `jpeg` 圖片。(72ppi，如果是要 1170px 寬的，就要跟他要個 1.5 倍或 2 倍大小的圖，這樣才能往下縮小並產生對應的檔案類型)。\n\n點陣圖要 `jpeg` 檔案會比較省空間。（用了 `sharp` 才發現 `png` 會比 `jpeg` 大）。\n\n另外轉 `avif` 和 `webp` 就交給 `sharp`。\n\n## IIS 設定 MIME 類型\n\n如果 IIS 沒有該類型要記得去設定不然你前端打一堆，server 都會誤以為 avif 和 webp 是 `text/html` 而無法顯示。\n\n- [How to add a MIME type to a Web site or application - Microsoft](https://learn.microsoft.com/en-us/iis/configuration/system.webserver/staticcontent/mimemap)\n\n- [How to Serve AVIF Image on IIS](https://www.itnota.com/serving-avif-image-iis/)\n","n":0.037}}},{"i":23,"$":{"0":{"v":"0202 [Javascript] CSV 檔數字千分位、字串都是數字","n":0.5},"1":{"v":"\n## CSV 檔數字千分位、字串都是數字\n\n### Demo\n\n[Demo](https://kiwijang.github.io/csvDemo/)\n\n![](/assets/images/2023-02-02-16-25-57.png)\n\n### csv\n\n[CSV - wiki](https://zh.wikipedia.org/zh-tw/%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94%E5%80%BC)\n\n逗號分隔值（Comma-Separated Values，CSV，有時也稱為字元分隔值，因為分隔字元也可以不是逗號），其檔案以純文字形式儲存表格資料（數字和文字）。純文字意味著該檔案是一個字元序列，不含必須像二進位數字那樣被解讀的資料。\n\n[MIME text - MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)\n\n> Text-only data including any human-readable content, source code, or textual data such as comma-separated value (CSV) formatted data. Examples include: text/plain, text/csv, and text/html. (Registration at IANA)\n\n所以 csv 是人類可讀的純文字。\n\n以 Demo 的內容為例，用逗號 `,` 分隔，可以看出這是一個表格:\n\n```javascript\n代號,時間,貨幣 // 表頭 \n=\"123\",2023-02-02,\"TWD 19,832,391,293\" // 第1行 \n=\"000004324\",2023-03-01,\"TWD 0.231123\"  // 第2行  \nBfwer123213f,2023-05-09,\"TWD -291,032,903.12312\" // 第3行  \n```\n\n備註:\n\n- `=\"000004324\"` 代號用 excel SUM 公式去寫是因為用 excel 打開有可能會變成數字，造成 0 消失...\n\n- `\"TWD 19,832,391,293\"` 貨幣有千分號所以要多加 `\"` 去做區隔，不然會被 csv 誤解。\n\n### 下載 csv\n\n```typescript\n\n// 我自訂的表格資料格式，要將這些資料轉換成上方用逗號個開的格式\ndemoData = [\n{\n    demoSeq: '123',\n    demoDate: '2023-02-02T00:00:00',\n    demoCurrency: 'TWD',\n    demoTotal: 19832391293,\n},\n{\n    demoSeq: '000004324',\n    demoDate: '2023-03-01T19:00:00',\n    demoCurrency: 'TWD',\n    demoTotal: 0.231123,\n},\n{\n    demoSeq: 'Bfwer123213f',\n    demoDate: '2023-05-09T00:00:00',\n    demoCurrency: 'TWD',\n    demoTotal: -291032903.12312,\n},\n];\n\n// 下載 csv\ndownloadCSV2() {\n    const headerKey = ['demoSeq', 'demoDate', 'demoTotal'];\n    const headerName = ['代號', '時間', '貨幣'];\n\n    // 轉換為我自訂的 tbody 資料格式:\n    // [[代號,時間,貨幣], [代號,時間,貨幣], [代號,時間,貨幣]]\n    const csvFileData = this.demoData.map((x) => {\n        const arr: (string | number)[] = [];\n        headerKey.forEach((key) => {\n        if (key === 'demoTotal') {\n            arr.push(\n            '\"' +\n                x.demoCurrency +\n                ' ' +\n                this._formateThousand((x as any)[key]) +\n                '\"'\n            );\n        } else if (key === 'demoDate') {\n            arr.push((x as any)[key].split('T')[0]);\n        } else {\n            arr.push((x as any)[key]);\n        }\n        });\n\n        return arr;\n    });\n    \n    // csv 表頭格式\n    let csv = headerName.join(',') + '\\n';\n\n    // 將自訂的 tbody 格式轉換為 csv 格式\n    csvFileData.forEach((row) => {\n        row = row.map((r, idx) => {\n        // idx !== 0 是指不是 [代號] 欄位才要加千分位，\n        // 其餘欄位若是數字就加千分位\n        if (idx !== 0 && (typeof r === 'number' || !isNaN(+r))) {\n            let result = '';\n\n            // 加千分位\n            result = this._formateThousand(r);\n\n            return '\"' + String(result) + '\"';\n        } else {\n            // [代號] 有可能都是數字 要顯示成字串\n            if (!isNaN(+r)) {\n            return '=\"' + String(r) + '\"';\n            }\n            return String(r);\n        }\n        });\n        csv += row.join(',');\n        csv += '\\n';\n    });\n\n    if (this.downloadRef2?.nativeElement) {\n        // 設定 html <a> 屬性讓他可下載 csv\n        this.downloadRef2.nativeElement.setAttribute(\n        'href',\n        'data:text/csv;charset=utf-8,\\ufeff' + encodeURI(csv)\n        );\n        this.downloadRef2.nativeElement.setAttribute(\n        'download',\n        `匯出報表_${formatDate(Date.now(), 'yyyyMMdd', this.localeId)}.csv`\n        );\n    }\n}\n```\n\n備註:\n\n- `data:text/csv;charset=utf-8,\\ufeff` 是 data URIs，代表 `text/csv` MIME 類型、以 `utf-8` 編碼、`\\ufeff` 避免亂碼。更多詳情請參閱 [data URIs - MDN](https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Basics_of_HTTP/Data_URLs)。\n\n    > data URIs, 由 RFC 2397 文件定義, 允許作者在文件中嵌入檔案.\n\n- 要加 `\\ufeff` 是為了避免 excel 開啟為亂碼，參考自 [JavaScript 瀏覽器端產生 csv 檔案 by jimmy8646](https://bonze.tw/javascript-client-generate-csv/)。\n\n- [位元組順序記號](https://zh.wikipedia.org/zh-hant/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F)\n\n    > 位元組順序記號（英語：byte-order mark，BOM）是位於碼點U+FEFF的統一碼字符的名稱。當以UTF-16或UTF-32來將UCS/統一碼字符所組成的字串編碼時，這個字符被用來標示其位元組序。它常被用來當做標示文件是以UTF-8、UTF-16或UTF-32編碼的記號。\n\n### 千分位加逗號\n\n```typescript\n  /**\n   * 千分位加逗號\n   * @param numberStr string | number\n   * @returns string\n   */\n  private _formateThousand(numberStr: string | number): string {\n    let result = '';\n    let numStr = String(numberStr);\n\n    const isMinus = numStr[0] === '-' ? true : false;\n    if (isMinus) {\n      const numStrArr = numStr.split('');\n      numStrArr.shift();\n      numStr = numStrArr.join('');\n    }\n    const arr = numStr.split('.');\n    // 整數位\n    const int = arr[0];\n    const intArr = int.split('');\n    const len = intArr.length;\n    // 總共會有幾個千分位逗號\n    let commasCount = Math.floor(len / 3);\n\n    // 被整除的話要減一(第一位不用千分逗號)\n    if (len % 3 === 0) {\n      commasCount = commasCount - 1;\n    }\n    // 千分位加逗號\n    for (let i = 1; i <= commasCount; i++) {\n      intArr.splice(len - 3 * i, 0, ',');\n    }\n\n    if (arr.length <= 1) {\n      // 沒有小數點以下\n      result = intArr.join('');\n    } else {\n      const point = arr[1];\n      // 小數點以下加回\n      result = intArr.join('') + '.' + point;\n    }\n\n    // 負數要把-加回\n    return isMinus ? '-' + result : result;\n  }\n```\n\n## 小結\n\n- 設定格式的 Data URIs `data:text/csv;charset=utf-8,\\ufeff` 包含 MIME 類型、編碼、`utf-8` 的十六進位用 `\\ufeff` 表示。\n\n- Math.floor() 無條件捨去，正負都會往右移(變小)。\n\n```javascript\n\n // 正→負排列圖:\n → [1.4] →  → → [0] → [-1.4] → \n\n // 無條件捨去\n              ↓                      ↓\n → [1.4] → [1] → [0] → [-1.4] → [-2] →\n```\n","n":0.044}}},{"i":24,"$":{"0":{"v":"2022","n":1}}},{"i":25,"$":{"0":{"v":"1210 [Flutter] 使用 VS Code 在 Windows 上開發 Android App","n":0.316},"1":{"v":"\n## Flutter\n\n[Flutter - wiki](https://zh.wikipedia.org/zh-tw/Flutter)\n\n### Dart\n\n> Flutter是使用Dart語言編寫，並利用該語言的許多進階功能。\n> 在Windows、macOS和Linux上，Flutter在Dart虛擬機器中執行，該虛擬機器具有即時編譯執行引擎。\n> 在編寫和除錯應用程式時，Flutter使用即時編譯功能進行「熱重載」(Hot Reload)，可以將對原始檔的修改注入正在執行的應用程式中。\n\n### Flutter 引擎\n\n> Flutter的引擎主要使用C++開發，透過Google的Skia圖形函式庫提供底層彩現支援，亦提供平台相關的SDK，例如Android和iOS。\n> Flutter引擎是用於代管Flutter應用程式的可移植的執行環境。它實現了Flutter的核心程式庫，包括動畫和圖形、檔案和網路I/O、可存取性支援、外掛程式架構以及Dart執行環境和編譯工具鏈。\n> 大多數開發人員將透過Flutter框架與Flutter進行互動，該框架提供了一個現代、回應式的框架，以及一組豐富的平台、版面配置和基礎元件。\n\n### Flutter’s Compilation Patterns 編譯方式\n\n[Flutter’s Compilation Patterns by stephenwzl](https://proandroiddev.com/flutters-compilation-patterns-24e139d14177)\n> 開發時用 Kernel Snapshot，發布時則根據不同平台用不一樣的編譯方式。\n\n### 安裝 Flutter\n\n[Windows install - Flutter 官網](https://docs.flutter.dev/get-started/install/windows)\n\n#### 下載 flutter SDK\n\n> Warning: Do not install Flutter to a path that contains special characters or spaces.\n> Warning: Do not install Flutter in a directory like C:\\Program Files\\ that requires elevated privileges.\n\n#### 將 flutter 加入使用者環境變數\n\n![](/assets/images/2022-12-10-21-22-03.png)\n\n\n### 設定 VS code(安裝 Flutter extention)\n\n[Set up an editor - Flutter 官網](https://docs.flutter.dev/get-started/editor)\n\n### 設定 Android\n\n[Android setup](https://docs.flutter.dev/get-started/install/windows#android-setup)\n\nAndroid App 是以 Java 撰寫而成，故要有 Java 開發環境與安裝 Android SDK。\n\n無論你用 Android Studio 還 VS Code 開發都要安裝:\n\n1. 安裝 Java SDK\n   \n  `C:\\Program Files\\Java\\jdk-18.0.1.1` 在這個路徑可以找到你安裝的 Java SDK 版本。\n\n2. 讓編輯器找的到你的 Java SDK 位置，設定 `JAVA_HOME`\n   \n   ![](/assets/images/2022-12-10-21-56-42.png)\n\n3. 安裝 Android SDK\n\n    `C:\\Users\\使用者名稱\\AppData\\Local\\Android\\Sdk` 可以看到你安裝的 Android SDK。\n\n    ![](/assets/images/2022-12-10-22-23-30.png)\n    > 可以直接用 Android Studio 管理 Android SDK。\n   \n4. 如果想使用 cmd 管理 Android SDK，安裝 sdkmanager 並設定環境變數(可略過這步直接用 Android Studio 管理 Android SDK 就好)\n\n    #### 用 cmd 管理 Android SDK\n\n    ##### 關於 sdkmanager\n    [sdkmanager](https://developer.android.com/studio/command-line/sdkmanager)\n\n    ##### sdkmanager 下載頁面與安裝和設定 cmd 環境變數\n\n    ![](/assets/images/2022-12-10-21-27-03.png)\n    ![](/assets/images/2022-12-10-21-27-23.png)\n\n    根據 [sdkmanager](https://developer.android.com/studio/command-line/sdkmanager) 裡的安裝步驟。\n    > 下載完解壓縮後，要創建一個 `latest` 資料夾，將檔案移入。\n\n    ![](/assets/images/2022-12-10-21-35-01.png)\n    > 因為以前有安裝過 Android Studio 所以有安裝 Android SDK 了，我是放在這: `C:\\Users\\使用者名稱\\AppData\\Local\\Android\\Sdk\\cmdline-tools\\latest`\n   \n    #### 將 sdkmanager cmdline-tools 加入使用者環境變數\n\n    ![](/assets/images/2022-12-10-22-09-18.png)\n\n\n### 檢查環境是否可跑 flutter\n\n`flutter doctor` 可以幫你檢查你的環境有那些沒安裝，沒安裝的照指示安裝就好了。\n\n![](/assets/images/2022-12-10-21-42-41.png)\n\n> 譬如這個就是 Visual Studio 沒有安裝 C++ 的東西。(如果沒要用 Visual Studio 開發 Flutter 可以忽略xD)\n\n### 新增一個 Flutter App\n\n[Test drive - Flutter 官網](https://docs.flutter.dev/get-started/test-drive)\n\n> 注意檔案的所有路徑都不可以有中文，不然 `flutter run` 會失敗...\n\n### 使用 ADV Manager 新增 Android 模擬器\n\n直接用 Android Studio 新增最方便xD\n\n![](/assets/images/2022-12-10-22-25-34.png)\n> 選擇裝置\n\n![](/assets/images/2022-12-10-22-26-38.png)\n> 選擇 API 版本\n\n![](/assets/images/2022-12-10-22-27-28.png)\n> 設定些東西(這邊使用預設)，按 Finish\n\n![](/assets/images/2022-12-10-22-28-32.png)\n> 剛剛新增的 AVD\n\n![](/assets/images/2022-12-10-22-31-19.png)\n> 到 VS Code 就可以看到了!\n\n![](/assets/images/2022-12-10-22-33-11.png)\n\n![](/assets/images/2022-12-10-22-35-21.png)\n> 打開 `main.dart` 檔案後按 `F5` 或點菜單 `Run > Start Debugging`，App 就可以成功跑在模擬器上了!\n\n![](/assets/images/2022-12-10-22-38-39.png)\n> Widgets Inspector 超酷的...[inspector - Flutter 官網](https://docs.flutter.dev/development/tools/devtools/inspector)\n\n\n### Flutter Devtools in VS Code\n[devtools(vscode) - Flutter 官網](https://docs.flutter.dev/development/tools/devtools/vscode)\n\n![](/assets/images/2022-12-10-22-46-02.png)\n> 可在 VS Code 裡打開 devtool\n\n![](/assets/images/2022-12-10-22-42-55.png)\n> 在瀏覽器中打開 devtool\n\n\n## 小結\n\nFlutter 很好用的感覺!! 之後就是來寫寫看應用程式了!!","n":0.062}}},{"i":26,"$":{"0":{"v":"1115 [Angular] 讓 mainjs 變小","n":0.447},"1":{"v":"\n## 讓 main.js 變小\n\n1. 將 main.js 內的元件抽出去變成 lazyload 的。\n2. 使用 esm 讓 angular 幫忙 tree-shake，最終只會包含你有使用的部分。\n\n## 視覺化工具\n\n主要是參考這篇文章:\n\n[How To Analyze Angular App Bundle Sizes with webpack Bundle Analyzer or source-map-explorer by Alligator.io](https://www.digitalocean.com/community/tutorials/angular-bundle-size)\n\n主要參考這篇文章: https://www.digitalocean.com/community/tutorials/angular-bundle-size\n\n## 加入四個指令到 package.json:\n\n```\n\"build:stats\": \"ng run client:build --configuration=sit --base-href=/xxx/ --stats-json\",\n\"analyze\": \"webpack-bundle-analyzer dist/apps/xxx/stats.json\",\n\"client:build:sourcemap\": \"ng run client:build --configuration=sit --base-href=/xxx/ --build-optimizer --source-map\",\n\"sourcemap:analyze\": \"npx source-map-explorer dist/apps/xxx/main.*.js\"\n```\n\n## 並有安裝套件到 devDependencies:\n\n```\n\"source-map-explorer\": \"^2.5.2\",\n\"webpack-bundle-analyzer\": \"^4.4.2\"\n```\n\n● 記得先更新套件:\n\n```\nnpm i\n```\n\n● webpack-bundle-analyzer 套件依序使用這兩個指令:\n\n```\nnpm run build:stats\nnpm run analyze\n```\n\n● source-map-explorer 套件依序使用這兩個指令:\n\n```\nnpm run client:build:sourcemap\nnpm run sourcemap:analyze\n```\n","n":0.12}}},{"i":27,"$":{"0":{"v":"1103 Meta 標籤設定 line、fb、twitter 顯示","n":0.447},"1":{"v":"\n## HTML 的 Meta 標籤\n\n主要可以看這篇文章:\n\n[The Essential Meta Tags for Social Media by Adam Coti on Jun 20, 2016](https://css-tricks.com/essential-meta-tags-social-media/)\n\n\n這篇 FB 寫的文章有介紹每個屬性，可以點進去看看:\n\n[The Open Graph protocol](https://ogp.me/)\n> The Open Graph protocol enables any web page to become a rich object in a social graph. For instance, this is used on Facebook to allow any web page to have the same functionality as any other object on Facebook.\n> \n> The Open Graph protocol was originally created at Facebook and is inspired by Dublin Core, link-rel canonical, Microformats, and RDFa. The specification described on this page is available under the Open Web Foundation Agreement, Version 0.9. This website is Open Source.\n\n## 預覽在社群網站的呈現 (Facebook / Twitter / LINE)\n\n這篇文章寫得超詳細:\n\n[如何讓 Facebook / Twitter / LINE 正確顯示你的連結預覽？ by Alyssa 2021-02-05](https://blog.alyssachan.space/wp-content/cache/all/update-link-preview-on-social-media/index.html#line)\n\n### 主要是這三個:\n\n- FB 的預覽網站(需登入)\nhttps://developers.facebook.com/tools/debug/\n\n- twitter 的預覽網站(需登入)\nhttps://cards-dev.twitter.com/validator\n\n- line 的預覽網站(無需登入)\nhttps://poker.line.naver.jp/\n\n\n## 小結\n\n``` html\n<!-- 自己以後遇到可以直接這麼用 -->\n<meta property=\"og:title\" content=\"European Travel Destinations\">\n<meta property=\"og:type\" content=\"website\" />\n<meta property=\"og:description\" content=\"Offering tour packages for individuals or groups.\">\n<meta property=\"og:image\" content=\"http://euro-travel-example.com/thumbnail.jpg\">\n<meta property=\"og:url\" content=\"http://euro-travel-example.com/index.htm\">\n<meta name=\"twitter:card\" content=\"summary_large_image\">\n\n<!-- 第一篇 css-tricks 文章整理的 -->\n<!--  Essential META Tags -->\n<meta property=\"og:title\" content=\"European Travel Destinations\">\n<meta property=\"og:type\" content=\"article\" />\n<meta property=\"og:image\" content=\"http://euro-travel-example.com/thumbnail.jpg\">\n<meta property=\"og:url\" content=\"http://euro-travel-example.com/index.htm\">\n<meta name=\"twitter:card\" content=\"summary_large_image\">\n\n<!--  Non-Essential, But Recommended -->\n<meta property=\"og:description\" content=\"Offering tour packages for individuals or groups.\">\n<meta property=\"og:site_name\" content=\"European Travel, Inc.\">\n<meta name=\"twitter:image:alt\" content=\"Alt text for image\">\n\n<!--  Non-Essential, But Required for Analytics -->\n<meta property=\"fb:app_id\" content=\"your_app_id\" />\n<meta name=\"twitter:site\" content=\"@website-username\">\n```","n":0.07}}},{"i":28,"$":{"0":{"v":"0919 [Angular] Subject","n":0.577},"1":{"v":"<!-- \ndate: 2020-05-16 09:34:52\n -->\n## 初探 Angular Subject\n從 Angular Subject 看到 RxJS Subject\n<!-- more -->\n### Angular Subject\n> Every Subject is an Observable. Every Subject is an Observer.\n> subject 是 observable 也是 observer。\n\nEventEmitter 是繼承 Subject 的 Class，之前有用到 EventEmitter 的地方在元件的溝通。\n![](https://i.imgur.com/6bjsuRk.png)\n\n## Angular 元件的溝通\n資料來源: https://stackoverflow.com/questions/37587732/how-to-call-another-components-function-in-angular2\n元件溝通有四種，父傳子、子傳父、相鄰子元件、不相關的元件\n![](https://i.imgur.com/8RYwc55.png)\n## 子傳父\n用到 EventEmitter。\n![](https://i.imgur.com/ZHZMY5h.png)\n\n## 元件傳元件\n用到 BehaviorSubject。\n![](https://i.imgur.com/XJGFBXh.png)\n\n---\n# RxJS Subject\n## 什麼是 Subject ?\nSubject 是 Observable 也是 Observer 。\n### Observable(可觀察的物件)\n代表一組未來即將產生的事件資料(被觀察的物件)\n\n### Observer (觀察者物件)\n代表一個用來接收「**觀察結果**」的物件(收到的就是**事件資料**)\n觀察者物件就是一個物件包含 **3** 個含有**回呼函式**的屬性(**next, error, complete**)\n\n### Subscription (訂閱物件)\n代表正在執行 Observable/Observer 的執行個體(可用來**取消訂閱**)\n\n### Subject (主體物件)\n如同 EventEmitter 一樣，主要用來**廣播**收到的事件資料給多位 Observer (觀察者) \n\n## 什麼是 Subject ?\nSubject 是 Observable 也是 Observer 。\n> observable.subscribe(observer); \n\n![](https://i.imgur.com/RJYMCHW.png)\n\nRxJS 裡的 Subject 有 4 種類型，Subject、BehaviorSubject、ReplaySubject 、 AsyncSubject\n\n參考來源:\nhttps://rxjs.dev/guide/subject\nhttp://reactivex.io/documentation/subject.html\nhttps://medium.com/angular-in-depth/mastering-rxjs-operators-and-functions-that-can-bite-you-when-you-dont-expect-cb2047cf5d4c\n\n## Subject、BehaviorSubject\n回傳訂閱前後到complete()前的範圍\n![](https://i.imgur.com/H0Jty8h.png)\n回傳訂閱後到complete()前的範圍\n![](https://i.imgur.com/is3H2L9.png)\n[Subject、BehaviorSubject Demo](https://codepen.io/kiwijang/pen/abvGGwy?editors=0012)\n\n## ReplaySubject、 AsyncSubject\n![](https://i.imgur.com/HNrqWS5.png)\n第一次訂閱:回傳訂閱前後到complete()前的範圍\n之後訂閱:回傳訂閱前所有值(無視complete())\n\n回傳complete()前一個值\n![](https://i.imgur.com/Vp7NzCY.png)\n![](https://i.imgur.com/zeniMhc.png)\n[ReplaySubject、 AsyncSubject Demo](https://codepen.io/kiwijang/pen/vYNjrBw)\n\n### 小結\n![](https://i.imgur.com/WHqXqic.png)\n* observable 被 subscribe 以後會有一個 observer 物件\n* observer 這個物件具有三個方法，分別是 next, error, complete\n* subscribe 會 return subscription(訂閱物件)\n---\n### 簡寫 observer\n![](https://i.imgur.com/DDj8Wrd.png)\n\n---\n\n參考資料:\n* [rxjs 官網](https://rxjs.dev/)\n* [RxJS 6 新手入門 - 保哥 youtube](https://www.youtube.com/watch?v=BA1vSZwzkK8&t=)\n* [reactive.how](https://reactive.how/)\n* [RxJS Marbles: Built on RxJS v5.0.3](https://rxmarbles.com/)\n* [[S05E04]RxJS 基本介紹 - Subject](https://www.youtube.com/watch?v=9udVLO947kk&t=1224s)\n* [What is the difference between Subject and BehaviorSubject?](https://stackoverflow.com/questions/43348463/what-is-the-difference-between-subject-and-behaviorsubject)\n* [30 天精通 RxJS(23): Subject, BehaviorSubject, ReplaySubject, AsyncSubject](https://ithelp.ithome.com.tw/articles/10188677)\n* [深入浅出RxJS.pdf](https://github.com/kekeqy/ebook/blob/master/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARxJS.pdf)","n":0.082}}},{"i":29,"$":{"0":{"v":"0907 [C#] 從 List 到 IEnumerable 和 IQueryable","n":0.354},"1":{"v":"\n## IEnumerable vs List - 如何使用? 他們是如何運作的?\n\n以下取自: https://stackoverflow.com/questions/3628425/ienumerable-vs-list-what-to-use-how-do-they-work/3628465\n\n- 一個類別實作 `IEnumerable` 的話，可以讓你使用 `foreach` 語法。\n\n  > A class that implement `IEnumerable` allows you to use the `foreach` syntax.\n\n- 一個 `IEnumerable` linq 陳述式，當你在使用 `foreach` 的時候會執行迭代，但你可以使用 `.ToList()` 強迫他馬上迭代。\n\n  > An `IEnumerable` linq statement executes when you iterate the `foreach`, but you can force it to iterate sooner using `.ToList()`.\n\n- `IEnumerable` 是唯獨的，而 `List` 並不是.\n\n  > `IEnumerable` is read-only and `List` is not.\n\n- 當你使用 `IEnumerable` 你給編譯器一個機會推遲執行，在這期間可能有所優化。\n\n  > When you use `IEnumerable`, you give the compiler a chance to defer work until later, possibly optimizing along the way.\n\n- 如果你使用 `ToList()` 你強迫編譯器馬上實體化出結果。\n  > If you use `ToList()` you force the compiler to reify(實體化) the results right away.\n\n## LINQ 不會產生 Sql 去查詢(query)資料庫，直到你列舉(enumerate)他\n\n    > LINQ doesn't generate the SQL to query the database until you enumerate it\n\n- `IEnumerable` 可以放置(stacking) LINQ expressions。\n\n- e.g 當你用 `foreach` 列舉，或者使用 `ToList()` 才會執行查詢資料庫的動作。\n\n# 小結\n\n因為 linq 在你列舉他之前，不會去馬上去資料庫抓資料。\n列舉就是指 foreach 和 toList()\n他說 IEnumerable 可以拿來放 LINQ expressions。\n最後要拿資料再 toList() 就好\n\n## IEnumberable 的大缺點\n\n- [最全数据结构详述: List VS IEnumerable VS IQueryable VS ICollection VS IDictionary](https://www.cnblogs.com/powertoolsteam/p/4936818.html)\n\n  > 使用 IEnumberable 會從服務器端將所有數據拷貝到客戶端，並進行一定的過濾，如果服務器端有大量數據會造成內存負載超重。\n\n## `IEnumerable` vs `IQueryable`\n\n- [Returning `IEnumerable<T>` vs. `IQueryable<T>`](https://stackoverflow.com/questions/2876616/returning-ienumerablet-vs-iqueryablet)\n\n  > The difference is that `IQueryable<T>` is the interface that allows LINQ-to-SQL (LINQ.-to-anything really) to work. So if you further refine your query on an `IQueryable<T>`, that query will be executed in the database, if possible.\n\n  > For the `IEnumerable<T>` case, it will be LINQ-to-object, meaning that all objects matching the original query will have to be loaded into memory from the database.\n\n## 小結\n\n- 先備觀念:\n  linq 在列舉後才會到資料庫撈資料。\n\n- 問題: `IEnumerable<T>` 和 `IQuertable<T>` 差別\n\n  - `IEnumerable<T>`\n\n  1. LINQ-to-object 可以放置(stacking) LINQ expressions\n  2. 但無法修改(新增刪除)。\n  3. 列舉時，無論有無下查詢條件，都會從 server 將所有數據拷貝到 client (`select * from [dbo.xxx]`)。\n\n  - `IQuertable<T>`\n\n  1. allows LINQ-to-SQL (LINQ-to-anything really)\n  2. 可以放置(stacking) LINQ expressions。\n  3. 在列舉前都可對查詢條件做修改。\n\n### 可以看這兩篇範例，會更清楚\n\n- [關於`IQueryable<T>`特性的小實驗](https://blog.darkthread.net/blog/iqueryable-experiment/)\n\n- [最全数据结构详述: List VS IEnumerable VS IQueryable VS ICollection VS IDictionary](https://www.cnblogs.com/powertoolsteam/p/4936818.html)\n  > ![](/assets/images/2022-09-07-22-36-54.png)\n\n## 參考資料\n\n- [關於 `IQueryable<T>` 特性的小實驗](https://blog.darkthread.net/blog/iqueryable-experiment/)\n\n- [最全数据结构详述: List VS IEnumerable VS IQueryable VS ICollection VS IDictionary](https://www.cnblogs.com/powertoolsteam/p/4936818.html)\n\n- [IEnumerable v.s IQueryable](https://dotblogs.com.tw/UgiYo/2019/08/10/001704)\n\n- [[Web API] 讓 Web API 支援 OData 查詢](https://dotblogs.com.tw/joysdw12/2013/06/07/web-api-odata)\n","n":0.056}}},{"i":30,"$":{"0":{"v":"0830 在 Windows 使用 MacOS 虛擬機 (使用 WSL2 + OSX-KVM)","n":0.316},"1":{"v":"\n## 1. 簡述過程\n\n想在 Windows 上使用 safari 來檢查網頁畫面是否跑版。\n\n所以要讓開發中的 Angular 網站在開發同時同步顯示在 MacOS 虛擬機中的 safari、IOS 虛擬機中的 safari 中。\n\n使用 WSL2 -> 安裝 Ubuntu -> 在 Ubuntu 裡面安裝 QEMU -> 透過 OSX-KVM 安裝 MacOS -> 透過 OSX-KVM 用 QEMU 開啟 MacOS 的虛擬機 -> 在 MacOS 虛擬機中安裝 Xcode 並使用 IOS 模擬器。\n\n最後設定一些東西，讓此 WSL2 內的虛擬機可以連上電腦本機的 localhost (還有設定螢幕大小和硬體配置)。\n\n## 2. 軟硬體需求\n\n### 2.1. WSL2\n\nWindows 10 2004 版和更新版本， (組建 19041 和更新版本) 或 Windows 11。\n\n### 2.2. Ubuntu\n\nOSX-KVM 需求: Ubuntu 20.04 LTS 64-bit 或更新版本.\n\n> A modern Linux distribution. E.g. Ubuntu 20.04 LTS 64-bit or later.\n\n### 2.3. OSX-KVM\n\n- QEMU >= 4.2.0\n\n- A CPU with Intel VT-x / AMD SVM support is required (grep -e vmx -e svm /proc/cpuinfo)\n\n- A CPU with SSE4.1 support is required for >= macOS Sierra\n\n- A CPU with AVX2 support is required for >= macOS Mojave\n\nNote: Older AMD CPU(s) are known to be problematic. AMD FX-8350 works but Phenom II X3 720 does not. Ryzen processors work just fine.\n\n![](/assets/images/2022-10-20-16-43-25.png)\n\n> 根據此網站以 i7-12700 為例以上硬體需求都有支援: https://openbenchmarking.org/s/Intel+Core+i7-12700\n\n以上需求來自: [OSX-KVM#requirements](https://github.com/kholia/OSX-KVM#requirements)\n\n## 3. Ubuntu\n\n![](/assets/images/2022-09-23-23-42-01.png)\n\n> 到 Microsoft Store 下載 Ubuntu 這邊是安裝 20.04.1 LTS，現在有更新的版號可以下載。\n\n### 3.1. 設定 Windows 功能\n\n(1) `win + R` 在執行視窗輸入 `optionalfeatures` \n![](/assets/images/2022-10-25-09-59-45.png)\n\n(2) 「開啟或關閉 Windows 功能」\n\n![](/assets/images/2022-10-25-10-01-35.png)\n\n確定這幾個功能都有被打勾，並在套用後重開機。\n\n- 虛擬機器平台 (Virtual Machine Platform)\n- Windows Hypervisor 平台 (Windows Hypervisor Platform)\n- Windows 子系統 Linux 版 (Windows Subsystem for Linux)\n\n\n## 4. 安裝要用到的套件\n\n主要會使用 WSL2 提供的打開 Linux GUI 的功能來打開 QEMU。  \n[在 Windows 子系統 Linux 版上執行 Linux GUI 應用程式](https://learn.microsoft.com/zh-tw/windows/wsl/tutorials/gui-apps)\n\n### 4.1. 所以要先安裝 WSL2:\n\n#### 4.1.1. 之前沒有安裝過 WSL 的話\n\n(1) 以系統管理員身分執行 cmd 或 powershell:\n\n```cmd\nwsl --install\n```\n\n(2) 電腦要重開機。\n\n#### 4.1.2. 如果現在已經有安裝 WSL 了\n\n(1) 以系統管理員身分執行 cmd 或 powershell:\n\n```cmd\nwsl --update\n```\n\n(2) 用這指令重開 WSL:\n\n```cmd\nwsl --shutdown\n```\n\n### 4.2. 用 Ubuntu 打開 Linux GUI:\n\n#### 4.2.1. 打開步驟 3. 下載好的 Ubuntu\n\n![](/assets/images/2022-10-20-15-16-01.png)\n\n![](/assets/images/2022-10-20-15-18-37.png)\n\n> 按下去後會開啟終端機，會自動開始下載 ubuntu 的東西。\n\n注意:\n\n![](/assets/images/2022-10-25-09-51-36.png)\n> 如果遇到 `WslRegisterDistribution failed with error: 0x80370102\nPlease enable the Virtual Machine Platform Windows feature and ensure virtualization is enabled in the BIOS.`  請確認 3.1.(2) 的功能有開啟並重新開機並到 BIOS 做設定，可參考華碩 intel 主機板設定 Virtualization Technology 為 Enabled，如果是 AMD 主機板的話是要檢查 SVM Mode 有沒有 Enabled。\n\n![](/assets/images/2022-10-25-09-54-57.png)\n> [圖源華碩官網 - [主機板] Intel 主機板如何通過BIOS開啟虛擬化功能(Virtualization Technology)](https://www.asus.com/tw/support/FAQ/1043786/)\n\n\n![](/assets/images/2022-10-25-10-39-25.png)\n> 可以用 cmd `wsl --list --verbose` 看到發行版的版本是 WLS2。\n \n(1) 更新 ubuntu 套件\n\n```bash\nsudo apt update\n```\n\n(2) 試灌一個套件\n\n```bash\nsudo apt install nautilus -y\n```\n\n灌好以後輸入:\n\n```bash\nnautilus\n```\n\n![](/assets/images/2022-10-20-15-26-25.png)\n\n> 彈出視窗就代表在 windows 上成功運行 nautilus 這個 Linux GUI 了。\n\n### 4.3. 在 Ubuntu 安裝 QEMU 前\n\n#### 4.3.1. 設定套嵌化\n\nWSL2 沒有預設套嵌化，要自己設定 `nestedVirtualization=true`。\n\n設定方式:\n\n(1) 在 Windows 中，在用戶文件夾下新建一個 `.wslconfig` 檔案 `C:\\Users\\%User%\\.wslconfig`。（User 是你的 Windows 系统用户名）\n\n檔案內:\n\n```xml\n[wsl2]\nnetworkingMode=bridged\nvmSwitch=ex\nmemory=32G\nprocessors=8\nswap=32G\nlocalhostForwarding=true\nnestedVirtualization=true\npageReporting=true\nkernelCommandLine=intel_iommu=on iommu=pt kvm.ignore_msrs=1 kvm-intel.nested=1 kvm-intel.ept=1 kvm-intel.emulate_invalid_guest_state=0 kvm-intel.enable_shadow_vmcs=1 kvm-intel.enable_apicv=1\n```\n\n- 設定內容是參照這網站的 [允许 WSL 嵌套虚拟化](https://blog.hal.wang/7afa8fc1/#%E5%85%81%E8%AE%B8-WSL-%E5%B5%8C%E5%A5%97%E8%99%9A%E6%8B%9F%E5%8C%96)\n\n- `.wslconfig` 微軟官網說明:\n\nhttps://learn.microsoft.com/zh-tw/windows/wsl/wsl-config#wslconfig\n\n> 用來在以 WSL 2 版本執行的所有已安裝 Linux 發行版本之間全域設定設定。WSL 會偵測這些檔案是否存在、讀取內容，並在每次啟動 WSL 時自動套用組態設定。 如果檔案遺失或格式不正確， (不正確的標記格式設定) ，WSL 會繼續正常啟動，而不會套用組態設定。\n\n- `.wslconfig` 的配置及參數，微軟官網說明:\n\nhttps://learn.microsoft.com/zh-cn/windows/wsl/wsl-config#configuration-setting-for-wslconfig\n\n- kernelCommandLine 是拿來設定設定 QEMU 的東西，相關參考 [怎样设置 QEMU 支持 enable_apicv 和 enable_shadow_vmcs?](https://www.zhihu.com/question/338768967) \n\n![](/assets/images/2022-10-20-16-06-02.png)\n> 根據下面這個網站我的 CPU 是 i7-12700 有支持 APICv 和 shadow_vmcs\n> https://openbenchmarking.org/s/Intel+Core+i7-12700\n\n(2) 設定並儲存完後，用這指令重開 WSL:\n\n```cmd\nwsl --shutdown\n```\n\n### 4.4. 在 Ubuntu 安裝 QEMU 並安裝 MacOS\n\n#### 4.4.1. 安裝 OSX-KVM 與準備安裝 MacOS\n\n使用 OSX-KVM 安装 MacOS VM。\n\n- 參考網址:\n  [开始安装 MacOS](https://blog.hal.wang/7afa8fc1/#%E5%BC%80%E5%A7%8B%E5%AE%89%E8%A3%85-MacOS)\n\n- [kholia/OSX-KVM](https://github.com/kholia/OSX-KVM)\n\n(1) 安裝 QEMU 和相關套件\n\n```bash\nsudo apt-get install qemu uml-utilities virt-manager git wget libguestfs-tools p7zip-full make -y\n```\n\n(2) 設定參數\n\n根據 [這篇](https://www.ptt.cc/bbs/Linux/M.1622355127.A.128.html) Windows 10 會有因 KVM 的 msrs 糾錯導致 BSOD 的問題，因此也將忽略 msrs 的選項也加入\n\n```bash\necho 1 > /sys/module/kvm/parameters/ignore_msrs\n```\n\n(3) 設定權限\n\n```bash\nsudo usermod -aG kvm $(whoami)\nsudo usermod -aG libvirt $(whoami)\nsudo usermod -aG input $(whoami)\n```\n\n![](/assets/images/2022-10-20-17-37-50.png)\n\n> 註: 用 `vim /etc/group` 可以看到權限已經改變了\n\n相關參考:\n\n- [Linux 修改使用者帳號設定 – usermod](https://www.ltsplus.com/linux/usermod-modify-linux-account)\n\n  > 註: 當使用 “-G” 參數時, usermod 會將帳號從原來加入了的群組退出, 所以在 “-G” 參數前加入 “-a” 參數, 會保留原來的群組設定。\n\n- [Linux 组管理、用户管理、查看用户信息、usermod、which、切换用户、修改文件具体权限](https://www.cnblogs.com/wenshinlee/p/11163346.html)\n\n(4) clone OSX-KVM repo\n\n```bash\ngit clone https://github.com/kholia/OSX-KVM.git\n\ncd OSX-KVM\n```\n\n(5) 取得 macOS 安裝檔\n\n```bash\n./fetch-macOS-v2.py\n```\n\n執行後畫面如下，可以選取你要的 macOS 版本\n\n```bash\n$ ./fetch-macOS-v2.py\n1. High Sierra (10.13)\n2. Mojave (10.14)\n3. Catalina (10.15)\n4. Big Sur (11.6) - RECOMMENDED\n5. Monterey (latest)\n\nChoose a product to download (1-5): 4\n```\n\n> 我是選 5 Monterey\n\n(6) 將下載完的檔案轉檔\n\n```bash\ndmg2img BaseSystem.dmg BaseSystem.img\n```\n\n(7) 新增一個虛擬 HDD image 將拿來灌 macOS\n\n```bash\nqemu-img create -f qcow2 mac_hdd_ng.img 256G\n```\n\n> mac_hdd_ng.img 是文件名，可以任意修改\n\n#### 4.4.2. 安裝 MacOS\n\n(1) 修改腳本\n\n先修改 `OpenCore-Boot.sh` 文件，設定 MacOS 的虛擬硬體規格。\n\n```bash\nvim ./OpenCore-Boot.sh\n```\n\n- `ALLOCATED_RAM` 記憶體，建議至少 8GB\n- `CPU_THREADS` CPU 執行緒\n- `CPU_CORES` CUP 核心\n- `-drive id=MacHDD,if=none,file=\"$REPO_PATH/mac.img\",format=qcow2` 其中的 `$REPO_PATH/mac_hdd_ng.img` 是上一步驟建立的虛擬 HDD。\n\n![](/assets/images/2022-10-20-18-04-53.png)\n\n> 這是我目前的設置\n\n(2) 執行腳本\n\n```bash\n./OpenCore-Boot.sh\n```\n\n會以設定的規格打開虛擬機。\n\n(3) macOS 安裝畫面\n\n接下來跟安裝 macOS 一樣 ，可以參考這幾篇:\n\n- 這篇的 STEP 14 ~ STEP 28\n[10 分鐘學會如何在 VirtualBox 安裝 macOS Monterey！](https://adersaytech.com/practical-software/install-macos-on-virtualbox.html)\n\n- [QEMU-KVM安裝macOS Montery虛擬機 (Manjaro/Arch Linux) by Ivon Huang](https://youtu.be/dOvt5wKh2S4?t=42)\n\n### 4.5. 打開 macOS，並安裝 xcode\n\n```bash\ncd OSX-KVM\n./OpenCore-Boot.sh\n```\n\n選擇你的系統碟\n![](/assets/images/2022-10-20-18-31-39.png)\n\n接下來會跑一下一堆白字然後出現 apple icon loading 畫面\n\n最後會看到登入頁面，輸入密碼就會進到系統裡了。\n\n### 4.6. 在 macOS 裡下載 xcode\n\n用 macOS 裡的 safari 到這個網頁 https://developer.apple.com/download/all/\n\n登入開發者帳號後就可以下載所需的版本。\n\n- 參考:\n  [如何手動快速下載不同版本的 Xcode - by POY CHANG](https://blog.poychang.net/manually-download-multiple-versions-of-xcode/)\n\n注意: xcode 有對應 mac os 的版本:\nhttps://developer.apple.com/support/xcode/\n\n![](https://i.imgur.com/hilbXM6.png)\n\n自己是用 mac os 12.5.1 配 xcode 13.4.1\n這邊備份了 xcode 13.4.1 的 .xip 檔在公司雲端裡，可以在 MacOS 裡直接下載這個檔案，就不用登入後才能下載了:\n[公司的人才能檢視此檔案](https://miniasp-my.sharepoint.com/:u:/p/naomi/ERBrYC3PfxJMm6DmnBqSUmoB6OCNSqQUzQTjnzH3Wt2XUw?e=UOEmMf)\n\n![](/assets/images/2022-10-20-20-22-36.png)\n\n> 最後就可以選擇自己需要的模擬器來用了。\n\n![](/assets/images/wsl.gif)\n> 每次都這樣打開就可以使用了。\n\n> 我沒有用到 `virt-manager`，如果最後想用 `virt-manager` 可參考 [OSX-KVM#installation](https://github.com/kholia/OSX-KVM#installation) 或 [使用 virt-manager 管理](https://blog.hal.wang/7afa8fc1/#%E4%BD%BF%E7%94%A8-virt-manager-%E7%AE%A1%E7%90%86) 或 [QEMU/KVM for absolute beginners by Veronica Explains](https://youtu.be/BgZHbCDFODk)\n\n## 5. 相關設定\n\n### 5.1. Angular 在 ng serve 設定 `--host 0.0.0.0`\n\n在 `package.json` 設定 `--host 0.0.0.0` 就可以邊開發邊自動刷新模擬器上的畫面。\n![](/assets/images/2022-10-20-21-02-37.png)\n\n0.0.0.0 代表[預定閘門(Default Router)](https://zh.wikipedia.org/zh-tw/%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1) (註: [TCP/IP 協定與 Internet 網路：第五章 網際層協定 by 粘添壽](http://www.tsnien.idv.tw/Internet_WebBook/chap5/5-2%20IP%20%E9%80%9A%E8%A8%8A%E5%8D%94%E5%AE%9A.html))\n\nDefault Router 是對 IP 數據包中的目的地址找不到存在的其他路由時，路由器所選擇的路由。\n\n\n`--host 0.0.0.0` 不知道什麼原理，讓這樣可以以本機 IP host 在網路裡@@\n[How to allow access outside localhost](https://stackoverflow.com/questions/43492354/how-to-allow-access-outside-localhost)\n\n本機 IP 要看 wifi 網卡的 IP，如果是用乙太網路的話就看該網卡的 IP (譬如: 網卡 IP 為 `192.168.1.2`，就在網址列輸入 `192.168.1.2:4200` 就可以連線到該網站了)。\n\n如果本機 IP 是固定的會方便很多不用每次都要本機 cmd `ipconfig /all` 查看目前 ip。\n\n另外如果有用 hyper-v 新增內部網路的虛擬交換器也可以用這個虛擬交換器的 ip 去連線(這個 IP 不是固定的，每次電腦重開機都會更新)。\n![](/assets/images/2022-10-25-18-21-37.png)\n\n\n![](/assets/images/2022-10-20-21-32-08.png)\n\n> 以此圖為例，這是用 hyper-v 建立的虛擬交換器，每次重啟電腦都會變，所以要在輸入網址時要先在本機 cmd `ipconfig /all` 查看目前 IP。 在 VM 裡的要測試的 angular 網站網址打上 `192.168.64.1:4200` 就可以連線了。\n\n### 5.1.1 沒辦法在 qemu 成功瀏覽\n\n在本機 windows `ng serve --host 0.0.0.0` 後打開 qemu。\n\n如果在 qemu 裡 `ping <你的網卡ip>` 可以成功，\n\n但在 qemu `http://<你的網卡ip>:4200` 沒辦法成功瀏覽的話，\n\n要到本機 windows 設定開啟 tcp 4200 port 的防火牆輸入/輸出規則。\n\n### 5.2. 畫面大小\n\n選 About This Mac 後選擇 Display\n![](/assets/images/2022-10-20-22-33-47.png)\n\n選擇 Displays Preferences\n![](/assets/images/2022-10-20-22-34-49.png)\n\n勾選 Show all resources 後就可以選擇自己想要的尺寸了\n![](/assets/images/2022-10-20-22-36-13.png)\n\n我是選 1600 x 900。\n\n因為我的螢幕是 27 吋 FHD，此視窗預設 1920 x 1080 會超出我的螢幕範圍(螢幕對這視窗來說太小了)，1600 x 900 大小就很合適。\n\n另外 QEMU 可以從 View > 打勾 Zoom to fit，這樣就可以調整自己想要的視窗大小，內容會等比縮放，所以你的螢幕解析度比較高的話，可以設定較大尺寸，再用這個來調整視窗大小，就不用為了讓視窗變小而讓解析度變低(設定小尺寸)。另外，解析度跟 RAM 有關，要確保自己的 RAM 有足夠空間再開高，不然會容易閃退。\n![](/assets/images/2022-10-20-22-40-49.png)\n\n## 6. 關於 Hyper-V 和 WSL\n\nHyper-V 是 Microsoft 的本機虛擬機器管理程式，它可以在執行 x86-64 位元的 Windows 上建立虛擬機器。(註: [Hyper-V - wiki](https://zh.wikipedia.org/zh-tw/Hyper-V))\n\nHyper-V 虛擬機器不支援 Hyper-V 以外的虛擬化應用程式。所以在安裝 ubuntu 的 Hyper-V 安裝 QEMU 會閃退。\n(註: [第三方虛擬化 App - microsoft](https://learn.microsoft.com/zh-tw/virtualization/hyper-v-on-windows/user-guide/nested-virtualization#3rd-party-virtualization-apps))\n\nWSL 是一個能夠執行原生 Linux 二進位可執行檔（ELF 格式）的相容層。可能就是因為如此才能不用透過 Hyper-V 就能調用硬體資源讓 QEMU 跑起來。 (註: [適用於 Linux 的 Windows 子系統 - wiki](https://zh.wikipedia.org/wiki/%E9%80%82%E7%94%A8%E4%BA%8ELinux%E7%9A%84Windows%E5%AD%90%E7%B3%BB%E7%BB%9F))\n\n另外有聽到 jserv 說 WSL 還沒有完成。\n\n利用 VM 來收費的服務如 [Parallels](https://www.parallels.com/hk/pd/general/?gclid=Cj0KCQjwkt6aBhDKARIsAAyeLJ1gnRx2t_B5JSxFMTQ-TwghqAIBta3I7jjfDYRc0fuu4EMzX3FKOeMaAtGFEALw_wcB) 就是利用 VM 讓 Mac 上可以同時執行 Windows 和 macOS，\n付費方式有三種($99.99、$119.99/yr、$149.99/yr)。\n\n或是雲端的 VM 譬如 [Amazon EC2 Mac 執行個體](https://aws.amazon.com/tw/ec2/instance-types/mac/) 也是要收費。\n\nOSX-KVM 作者對合法性有寫了一段說明 [Is This Legal?](https://github.com/kholia/OSX-KVM#is-this-legal)。OSX-KVM 是利用 OpenCore 下載 macOS 的 [Legality of Hackintoshing](https://dortania.github.io/OpenCore-Install-Guide/why-oc.html#common-myths)。\n\n## 7. 這篇筆記的起源與感想\n\n為了測試 Apple 裝置上的 safari 和 IOS 上的 safari 但手邊沒有相關裝置，\n\n用了保哥提過的 [BrowserStack](https://www.browserstack.com/?utm_source=google&utm_medium=cpc&utm_campaign=Search-Brand-Tier2-APAC&utm_adgroup=BrowserStack-Alpha&utm_keyword=browserstack&utm_matchtype=e&gclid=Cj0KCQjw48OaBhDWARIsAMd966DtkC0HouaetqSwwkXJ_BVh1-_-tZO4AZUvrqvR8_jZpaEBuK3yhAwaAm-IEALw_wcB) 但因為 API 有網域限制所以沒辦法使用這個做測試。\n\n所以一開始使用過 VirtualBox、後來有時間才換成使用 OSX-KVM + WSL2。\n\n使用感想是模擬器都會有畫面延遲的感覺，但 OSX-KVM + WSL2 的模擬器畫面延遲相較 virtualBox 還小一點。\n\n另外因為有閃退問題所以硬體從原本 RAM 32GB 擴充到 64GB，這樣邊用 vscode 和這個開發的時候大概會占掉 40GB 的記憶體，感覺是剛好夠用的。\n\n另外 CPU 會在 60~90% 跑來跑去，也是剛好蠻夠用的。\n\n後來買了顯示卡(本來是用內顯)，感覺動畫有比較平順，在模擬器內滑動頁面或切換頁面的時候 GPU 會在 15%~20% 跑，沒顯卡前用內顯只會用 0%~4% 在跑，所以顯示卡會有一點點幫助。\n\n但整體來說，如果要爽用的話 CPU 好一點會更順 xD\n\n另外，下面這個筆記記錄了使用 IIS、VirtualBox、和 android 的 remote debbuging 來測網站。\n\n> [(這篇筆記不公開) IIS、VirtualBox、和 android 的 remote debbuging](https://hackmd.io/vy1TyPnNRESPMTwMqNuPlA)\n\n---\n\n這整篇筆記主要是參考這篇文章，\n\n要是沒有看到這篇文章我也沒機會用用看 OSX-KVM + WSL2，\n\n因為找不到作者的名字所以就只附上網址，感謝這個作者、OSX-KVM 和免費好用的 WSL 還有我的新電腦和網路資源M( _ _)M。\n\n- 主要參考自: [在 Windows 上流畅使用 MacOS 虚拟机](https://blog.hal.wang/7afa8fc1/)\n","n":0.033}}},{"i":31,"$":{"0":{"v":"0608 組了一台桌電!","n":0.707},"1":{"v":"\n## 組了一台桌電!\n\n第一次自己從原價屋買零件組電腦，很有成就感\n\n紀錄一下\n\n首先是採購清單\n\n![](/assets/images/2022-06-08-21-26-46.png)\n\n裝好機後騎車去附近的順發 3C 買了一個硬碟\n\n![](/assets/images/2022-06-08-21-35-54.png)\n\n因為我要 CMR（Conventional Magnetic Recording）硬碟\n\n紅標比黃標便宜，且現在 Red Plus 為 CMR\n\n原本跟欣亞訂了黃標，錢都匯了等了 4 天都沒回覆，就只好請他們幫忙取消訂單並退款，雖然真的很抱歉取消訂單但真的太久了(被 momo 寵壞 w)\n\n總之後來就去順發現場買了，本來想買 6TB 但店員幫我查完以後說現在沒 6TB (全台門市只剩共 5 個)，所以就買了 4TB 的 (幸運)\n\n### 主機板、塔散、機殼與風扇\n\n主機板重裝了 3 次，第一次螺絲鎖錯(有三種螺絲: 粗牙、中牙、細牙)，主機板要用細牙，但我第一次用成中牙 orz\n\n第二次是發現主機殼少了兩個螺柱 orz\n\n第三次終於鎖對了 (我的 MSI B660M MORTAR WIFI DDR4 沒有附上說明書阿... 明明看別人開箱都有厚厚一本 QQ)\n\n可能是原價屋為了測主機板是否正常，會在出貨前幫使用者裝上記憶體和 CPU，那時封箱少放回說明書或是微星印刷成本太高取消印刷說明書 QQ\n\n---\n\n接下來我先裝 PA120 塔散(附扣具與散熱膏)，因為有附背板支架，所以我先把背板塑膠墊圈(墊在主機板與螺絲中間)+螺絲先放好，然後再從前面把螺柱鎖好\n\n接下來就是上散熱膏了^^\n我擠了 5 個米粒大小一長條在 CPU 中間 (因為看到 12 代 CPU 是直直排列的長方區塊)\n\n接下來把散熱片底部塑膠膜撕掉，放上散熱片、開始鎖上螺柱，一開始因為一邊鎖太多造成另一邊翹起來鎖不到螺柱，只好先鬆開到平衡一點才可繼續鎖另一邊\n\n---\n\n接下來就是裝風扇，因為我的主機殼載運或過程後面面板被壓到變形 (但急用，只好拿鐵鎚敲一敲 xd)\n\n還好這主機板的擋板是跟主機板一體的不用塞到機殼上，且還好我沒有顯示卡(凹槽都歪歪的)\n\n雖然沒辦法密合，但也是有散熱好的好處拉 xD 哈哈\n\n看別人測這張主機板的溫度都是 CPU 到後板那裏溫度最高\n\n機殼剛好都是右後方歪斜有縫隙 xD 但還是可以鎖得起來 (讚)\n\n---\n\n回到裝風扇話題，後方風扇因為我主機殼太歪，放主機板時一直找不到對齊的位置，所以就先把後風扇拆下對齊好主機板\n\n現在主機板跟塔散都裝好了，所以這顆風扇就照原本方式螺絲從外鎖上在內的風扇(線從左上方孔走背隔板)\n\n這主機殼有附風扇與 ARGB 串接板 (SATA 供電)!!!\n接完主機板送的三顆後還有一個燈+風扇的位置 (打算以後可以買一個薄風扇裝上機殼)\n\n是 ARGB (會變色的風扇!!)，且可以透過 RESET SW 切換顏色\n\n這個是弟弟幫我去 ptt 電蝦版發問  \n熱心網友們的推薦 (C+P 組合)  \n全漢 CST130b 配全漢黑爵士 D 550W (金牌/半模)  \n雖然半模比較難整線，但是好便宜阿!!!\n\n![](/assets/images/2022-06-08-23-01-10.png)\n\n> 圖源: [原價屋](https://www.coolpc.com.tw/tw/shop/case/fsp-cst130b-case/)\n\n裝好了以後就是整線，盡量把線都放在前面，避開 CPU 附近\n\n然後扣上塔散的兩個風扇 (總共 5 個風扇)\n\n因為這張主機板的風扇孔只有 2 個 4-pin 系統風扇接頭，所以要是沒有這個串接板可能要另外找串接線 [官網 spec](https://tw.msi.com/Motherboard/MAG-B660M-MORTAR-WIFI-DDR4/Specification)\n\n另外然後 PA120 有附串接線所以塔散兩個電風扇都可以插在 4-pin CPU 風扇接頭上\n\n之後我若要再買風扇，可以用主機殼送的串接槽或是主機板 4-pin 系統風扇接頭...\n\n![](/assets/images/2022-06-09-00-40-21.png)\n\n> 圖源: [手冊](https://tw.msi.com/Motherboard/MAG-B660M-MORTAR-WIFI-DDR4/support#manual)\n\n---\n\n接下來把 SSD 45 度角放到散熱片下再鎖上，沒有東西可以比 SSD M.2 更好裝的了 xD\n\n### 電供器與 HDD\n\n最後是電供器，因為我主機殼很小，所以裝完塔散和後方風扇後，CPU 8ping 和 4+4ping 電源超級難插...\n\n我只有用到這幾個電源，上面都有用白色印刷字寫插頭要插哪，超貼心(像 CPU 就有各寫在 8 pin 和 4+4 ping 上)\n\n串接板要插 SATA 供電、HDD 也用 SATA 供電\n\n所以我只用了這幾個\n\n![](/assets/images/2022-06-09-01-08-46.png)\n\n> 來源: [官網](https://www.fsplifestyle.com/PROP184003280/)\n\n---\n\n然後就是主機殼的音源、USB3.0、POWER SW、POWER LED(有分+-)、HDD LED(有分+-)、RESET SW (來的時候已經插好到串接板，所以是拿來控制燈泡顏色的~)\n\n> 參考影片: [【Huan】從組裝到灌系統的教學分享，組一台 TUF Gaming 主題的電競主機!](https://youtu.be/1BFpDa626Kk)\n\n安置完就可以開機了~\n\n看到風扇燈亮起的瞬間真的很感動 QQ\n\n---\n\n最後隔天是用主機板送的 SATA 線將從順發買來的 HDD 連到主板~\n\n![](/assets/images/2022-06-09-01-17-04.png)\n\n> 來源: [官網詳細](https://tw.msi.com/Motherboard/MAG-B660M-MORTAR-WIFI-DDR4/Specification)\n\n---\n\n### 曬曬電腦\n\n![](/assets/images/pc.jpg)\n\n> 最後把 i7、fury、msi 貼紙貼到機殼旁邊(機殼保護膜沒撕掉) xD\n\n![](/assets/images/pc2.jpg)\n\n> 背板的線，風扇不小心把風扇自帶的串接也接上去了，但是懶得找是哪個... 所以就先多接一個吧，哈哈\n\n這機殼材質還蠻軟爛的，以後要小心搬運過程中不要壓到\n\n### os 與驅動程式\n\n我是買 win10 彩盒版，因為電蝦版推用彩盒\n\nusb 上黏了一個膠帶，用橡皮擦清理了很久...\n\n跟用自己系統碟 usb 重灌不太一樣的是不用進 UEFI 就會直接導頁到安裝頁面，很方便，然後再輸入序號\n\n之後還灌了 wifi 驅動(用外接硬碟灌好後放到新電腦安裝)\n\n有 wifi 後我才開始接網路下載音效驅動\n\nwifi 可從 intel 下載\n\n- [wifi intel 驅動程式](https://www.intel.com.tw/content/www/tw/zh/download/19351/windows-10-and-windows-11-wi-fi-drivers-for-intel-wireless-adapters.html)\n\nwifi 和 audio 都可從主機版官網下載\n\n- [官網產品支援-驅動程式下載](https://tw.msi.com/Motherboard/MAG-B660M-MORTAR-WIFI-DDR4/support#driver)\n\n接下來就是升級成 win11\n\n---\n\n然後設定 XMP，用 MSI Memory Try It! 有選單可以選\n\n我就照這規格 DDR4-3200 CL16 來選擇自動產生預設的設定檔 xD\n\n![](/assets/images/2022-06-09-01-59-34.png)\n\n原本是 2400MHz 才變成包裝寫的 3200MHz\n\n超酷! 感覺這些參數都很值得深入探索一下 (總之跟作業系統很多專有名詞有關，感覺很有趣 xD)\n\n## 小結\n\n用這桌機和螢幕上班真的有效率多了 (編譯超快... RAM 超多)\n\n因為沒有打遊戲看影片需求，使用內顯、螢幕是 1920 x 1080 (Full HD)\n\n螢幕有附喇叭及螢幕旋轉架，雖然喇叭音效沒有很好但完全省去買這兩個東西的時間 ^^b (讚)\n\n且寫程式用直立螢幕還蠻適合的不用一直往下滾，開 devTool 也有比較多空間\n\n---\n\n人生中第一個大螢幕和自組電腦! 超棒 ^^b !\n\n自己裝電腦還認識了不少專有名詞，現在電腦都很貼心有防呆措施，很難裝錯，且 YT 也有一堆教學\n\n覺得很會組電腦的人基本電學一定都不錯，組電腦的電真的是很深奧的一門學問\n\n且韌體有很多演算法和資料結構應用的知識，感覺很厲害!\n\n### 相關資料\n\n這個頻道講得超讚，動畫也超讚\n\n- [【硬件科普】固态硬盘的缓存是干什么的？有缓存和无缓存有什么区别？](https://youtu.be/7ZJ4UFxaAZw)\n\n- [【硬件科普】高频内存为什么要打开 XMP？详解内存条 SPD 与 XMP](https://youtu.be/KC4CVyWXjRM)\n\n然後還有不少計組計結專有名詞的 CPU 設計\n\n- [【Huan】 來聊聊讓我期待的 12 代 intel 處理器: Alder Lake](https://youtu.be/cy1MHUEc7aA)\n\n---\n\n太棒了，科目應用大集合就在一台主機裡 ^q^\n\n**自組電腦有益身心**，是不是?! xD\n","n":0.065}}},{"i":32,"$":{"0":{"v":"0419 [系列文目錄] OS (一)","n":0.5},"1":{"v":"\n## 前言\n\n在買書的時候看到這篇文章:\n\n[[系列文目錄] 作業系統 Operating System Concepts by Mr. Opengate.](https://mropengate.blogspot.com/2017/09/operating-system-concepts.html)\n\n正好可以一起配著整理一份筆記。\n\n![[drops.2022.0419-drops.2022.0419-[Ch1]作業系統簡介與常見系統類型(二)]]\n\n## 參考資料\n\n- [Operating System Concepts, 10/e (GE-Paperback) by Abraham Silberschatz , Peter Raer Galvin , Greg Gagne](https://www.tenlong.com.tw/products/9781119454083)\n\n- [Building Modern Computers from Fundamentals: From NAND to Tetris (Project-Based Course) by Shimon Schocken、Noam Nisan、Hebrew University](https://www.coursera.org/learn/build-a-computer/home/welcome)\n\n- [洪逸作業系統](https://www.tkbgo.com.tw/product/toProductDetail.jsp?subject_no=S1707CS0000001&class_type=A)\n\n- [作業系統 (Operating Systems: Internals and Design Principles, 6/e) William Stallings 著、陳玄玲 譯](https://www.tenlong.com.tw/products/9789861548036)\n\n- [鳥哥的 Linux 私房菜](https://linux.vbird.org/)\n","n":0.132}}},{"i":33,"$":{"0":{"v":"0419 [Ch1]作業系統簡介與常見系統類型(二)","n":0.707},"1":{"v":"\n## 電腦系統概論 computer system structure\n\n### 組成電腦的五大單元\n\n![](/assets/images/2022-05-02-22-40-17.png)\n\n> 圖源: [第零章、計算機概論 - 鳥哥](https://linux.vbird.org/linux_basic/centos7/0105computers.php#ps4)\n\n![](/assets/images/2022-05-02-22-46-40.png)\n\n> 圖源: [馮紐曼架構 Von Neumann architecture](https://zh-yue.wikipedia.org/wiki/%E9%A6%AE%E7%B4%90%E6%9B%BC%E6%9E%B6%E6%A7%8B)/[Computer Organisation](https://en.wikibooks.org/wiki/IB/Group_4/Computer_Science/Computer_Organisation)\n\n1. 輸入單元 input device\n2. 輸出單元 output device\n3. CPU 內部的控制單元 control unit\n4. CPU 內部的算數邏輯單元 arithmetic/logic unit (ALU)\n5. 主記憶體 memory unit\n\n### 電腦系統粗分為四元件\n\n![](/assets/images/2022-05-02-23-43-42.png)\n\n1. 硬體 hardware\n\n   例如: cpu、disk、memory...\n\n2. 作業系統 operating system\n\n3. 應用程式與系統程式 application programs and sys programs\n\n4. 使用者 users\n\n   例如: 人、其他機器、其他系統...\n\n## 作業系統概述 OS Structure\n\n### OS 的目的\n\n1. user 與硬體之介面(方便使用者易於操作電腦)\n2. 提供一個讓 app 易於執行之環境，即很多底層硬體控制不需 app 來直接運作 => 委託 os 來執行\n3. 資源有限 => 作為資源調派者(resource allocator) (eg cpu, memory, I/O Device etc)\n\n   => 希望有效運用資源，甚至公平使用。\n\n4. 監督應用程式執行之角色，防止他們有意或無意之操作\n\n### 電腦系統架構\n\n1. 多處理器系統 Multiprocessor System / Parallel System / Tightly Coupled System- 又叫 Multiprocessing 或 paraller 或 tightly-coupled system。\n\n   - 主要 features 如下:\n     - 一部機器(或主機板)內置多顆處理器，均共享此一機器的 memory、bus、I/O devices, power-supply etc。\n     - 通常所有 CPUs 均受同一個 clock 之時脈控制。\n     - 通常由同一個 OS 管控所有 CPU。\n     - 這些處理器之間的溝通大都採共享記憶體方式。 [CH6]\n   - 優點\n     - 增加產能(Increased Throughput)\n     - 增加可靠性 (Increased Reliability)\n     - 規模經濟 (Economy of scale)\n   - 分述如下:\n     - 產能增加: 所以支持 parallel computing，同一時內可有多個工作在不同 CPUs 上平行執行。\n       - N 顆 CPUs 之產能絕對小於: 1 顆 CPU 產能\\* N 倍。\n       - 理由: 因為 (1) Resource Condition(資源競爭)。 (2) 處理器之間的溝通導致不見得工作可以平行執行\n         所以效能會被抵減。\n     - 提升可靠度: 萬一某 CPU 壞了，其他 CPU 仍可執行工作。\n       - 所以統不至於因而停頓。\n       - 名詞:\n         - graceful degradation 漸進式毀滅\n           系統不會因某些元件(e.g.硬體或軟體)的故障而停頓，仍保有持續運作的能力。\n         - Fault Tolerant system (容錯系統)\n           具有 graceful degradation 能力之系統。\n     - 運算能力之規模擴充比較具有經濟效益\n       - 這些多顆 CPUs 是共享此機器之記憶體、匯流排等其他資源，所以會比較省錢。\n\n   1. 最常見為 SMP(Symmetric Multi-Processing)\n\n      對稱式多處理器記憶體資源是共享的又稱 UMA(Uniform Memory Access)，所以會有資源競爭的問題。可用 CPU 排程和同步工具來解決遇到的問題(CH5、CH6)。\n\n      雙核(dual-core)設計的處理器將多個 CPU 放置同一晶片(chips)上，會比個放在不同晶片上更有效率且更省電(省電對筆電和手機來說很重要)。\n\n      快取級數越小代表體積越小、速度越快。\n\n      這種共用資源的 CPU 架構讓 OS 設計及程式設計變得很重要(CH4 執行緒與並行)。\n\n      ![](/assets/images/2022-05-03-22-41-34.png)\n\n      > 圖源: [Cache Memory | L1, L2 and L3 Caches in Computers | L1 L2 L3 Cache Explained in Hindi](https://www.youtube.com/watch?v=IU9cB5g4eZU&ab_channel=ITSimplifiedinHINDI)\n\n      當 CPU 變多，處理器和記憶體間的匯流排將會成為資料存取的瓶頸，會嚴重地影響到系統效能。[註 1]\n\n      為了解決多 CPU 的資源競爭問題，NUMA (Non-Uniform Memory Access) 的設計簡化了匯流排的複雜程度，NUMA 將處理器切成不同節點，每個處理器都有各自的連結，當要用到別的節點的記憶體時速度會變慢，但只用到自己的記憶體時不只速度快、也不會有資源競爭的問題(因為自己用自己的，去用別人的也只會有一條路)。\n\n      ![](/assets/images/2022-05-03-23-52-25.png)\n\n      > 圖源: [A NUMA architecture with 4 nodes - uploaded by Li Wang](https://www.researchgate.net/figure/A-NUMA-architecture-with-4-nodes_fig2_273393420)\n\n   2. ASMP(Asymmetric MultiProcessors) 非對稱式多處理器:通常採主從式架構。比 SMP 效能還差，主 CPU 易有效能瓶頸，且可靠度也差(主 CPU 壞了就全不能用)。\n\n   3. 叢集式系統 clustered system\n\n      1. 也是一種多處理器系統(Multiprocessor System)\n\n2. 分散式系統 Distributed System / Loosely Coupled system\n\n   多部機器彼此以網路相互串聯。機器間硬體資源不共享、各 CPU 時脈(clock)控制不一定相同、各 CPU 上的 OS 也不一定相同、處理器之間的溝通大都採 Message Passing 方式 (CH6)。\n\n   增加吞吐量(throughput)和可靠性(reliability)、減少資源共享、可滿足遠端通訊的需求。\n\n   可分成主從式架構與 P2P 架構。(就像 ASMP 和 NUMA 概念的差別，不是主從就是平權欸...)\n\n### 作業系統執行\n\n1. 多元程式設計系統 Multiprogramming\n\n   允許多個程序 (processes/jobs) 在記憶體裡同時執行。\n\n   - 主要目的: 提高 CPU 利用度 (utilization)。\n\n   - Mulitiprogramming degree 代表系統內執行的程序 (processes) 數目。\n\n     一般而言，若值愈高，CPU 利用度 (utilzation) 愈高。\n\n   - 多個工作 (processes/jobs) 同時執行的方法有兩種:\n\n     - 並行 Concurrent execution\n       通常發生在單核(一顆 CPU 時)\n\n     - 平行 Parallel execution\n       多顆 CPUs 或 MultiCores\n\n   1. 分時系統 Time-Sharing / Multitasking\n      又叫 multitasking，是一種多元程式的邏輯擴充 (logical extension)。\n      - 強調\n        - 回應時間要短。\n        - 對每個使用者工作要公平對待。\n        - 讓每個使用者覺得有自己專屬的電腦的感覺。\n      - 技術\n        - CPU 排班採用 RR 排班。[CH4]\n        - 有 Swapping 技術，即虛擬記憶體技術。[CH8]\n        - 有 SPOOLing 技術，讓每個使用者有自己的 I/O 設備的感覺，同時也有 Buffering 技術(使用記憶體)一併使用。\n\n2. Dual-Mode and Multimode Operation\n\n3. Timer\n\n4. 批次系統 Batch System\n\n---\n\n6. 即時系統 Real-Time System\n\n   1. Hard\n   2. Soft\n\n7. 手持系統 handheld system\n\n## 參考資料\n\n- 註一 [多核心計算環境—NUMA 與 CPUSET 簡介 by 周秉誼](https://www.cc.ntu.edu.tw/chinese/epaper/0015/20101220_1508.htm)\n\n#### 名詞解釋\n\n- CPU\n\n  執行指令(instructions)的硬體。\n\n- 處理器 Processor\n\n  包含一或多個 CPU 的物理晶片(chip)。\n\n- 核心 Core\n\n  CPU 的基本數量單位。\n\n- 多核心 Multicore\n\n  同 CPU 上包含多個運算核心。\n\n- Multiprocessor\n\n  包含多個處理器。\n","n":0.048}}},{"i":34,"$":{"0":{"v":"0327 關於 Monospace 字型在不同裝置顯示","n":0.5},"1":{"v":"\n## 一致化 vscode 和網站的 font-family\n\n上一篇文章用 `<pre>` 畫圖，結果發現手機的 `monospace` 顯示跟筆電的顯示結果不一樣(手機跑版了...)\n\n結果是因為字型沒有提供對應的符號:\n\n![](/assets/images/2022-03-27-23-11-59.png)\n\n> 用 Google Fonts 搜尋 `↑↓←→↖↗↙↘` 只有 [Nanum Gothic Coding](https://fonts.google.com/specimen/Nanum+Gothic+Coding?category=Monospace&preview.text=%E2%86%91%E2%86%93%E2%86%90%E2%86%92%E2%86%96%E2%86%97%E2%86%99%E2%86%98&preview.text_type=custom) 顯示所有箭頭符號...\n\n最後，為了讓寫 `.md` 檔看起來跟網頁一樣，從 Google Fonts 下載了該字體的 `.ttf`。\n\n![](/assets/images/2022-03-27-23-17-32.png)\n\n接著設定 vscode 字體。\n\n![](/assets/images/2022-03-28-00-00-32.png)\n\n因為自己比較喜歡寬扁的字體，這款是細長型的，還在適應中。\n\n這個字體的大於小於 `< >` 也是細長的，蠻特別的。\n\n字體作者為 `Sandoll`，是一間韓國的字體公司。\n\n[那個幫忙製作思源字體的公司——韓國字型公司 Sandoll by ⦿ 曼努 manzoo](https://medium.com/koom/profile-003-981476689afc)\n\n如果想知道 Google Fonts 怎麼用，可以參考這篇:\n\n[Web Font 的使用 by oxxo](https://www.oxxostudio.tw/articles/201406/css-web-font.html)\n\n## 使用 chrome devtool debug Android 裝置\n\n為了確保 `Android Browser`[註2] 可以正常顯示，用了 chrome 提供的功能。\n\n操作步驟:\n\n* 手機連接電腦後，手機選擇 `設定` > `進階人員選項` > 開啟 `USB 偵錯`。[註1]\n\n* 電腦 Chrome 網址輸入 `chrome://inspect/#devices`\n\n* inspect 要 debug 的網頁，就可以開始 debug 了。\n\n---\n\n更多詳情可參閱:\n\n* [Remote debug Android devices by Kayce Basques](https://developer.chrome.com/docs/devtools/remote-debugging/)\n\n* [Configure on-device developer options](https://developer.android.com/studio/debug/dev-options)\n\n---\n\n> 註1: xa2 sony 手機會自動開啟開發人員,如果你的手機沒自動開啟，可到 `設定` > `系統` > `關於手機` > `版本號碼` 點七下。這個技巧是在 [王紫楓](https://www.youtube.com/watch?v=8WuLsAFnOuc&list=PLhxdaTcUMi3lKmlyVVcWdeMsoyRPcyRLI) 我忘記哪支影片看到的，那時覺得他講話很像 godJJ 就把教學影片看完、還記到現在 xD\n\n> 註2: 在 Can I use 網站上 `Android Browser` 是一個項目 (本以為會同桌機版 Chrome，實則為不同瀏覽器項目)\n\n![](/assets/images/2022-03-27-23-28-23.png)","n":0.095}}},{"i":35,"$":{"0":{"v":"0322 RWD 排版固定或流動","n":0.577},"1":{"v":"\n因為設計稿給了三種尺寸 pc/pad/phone，\n\n然後程式裡有三個用 min-width 分開的中斷點 1170px/768px/320px\n\n(同事說:所以中斷點吃不到的地方就吃預設值)\n\n如下圖:\n\n``` javascript\n┌──────────────────┐\n│          sm      md      lg        │\n│          320     768     1170      │\n│ 預設值   │→    │→    │→      │\n└──────────────────┘\n  liquid 流動排版 ←│→ 固定排版 fixed\n```\n\n一開始想說應該是到中斷點就換版型的排版，結果好像是 pad(768px) 以下要變流動(Liquid)的排版。\n\n機會難得想把這篇文章的東西英翻中，記錄一下xD (文章作者是:Steven Bradley / May 30, 2006)\n\nhttps://vanseodesign.com/web-design/fixed-or-liquid-design/\n\n## Fixed Design 固定設計\n\n### 優點\n\n- 給予設計師控制 the control it gives the designer\n\n- 通常可以快速開發 generally quicker to develop\n\n- 適合使用背景圖片(background-images) easier to use background images which by nature will have fixed dimensions\n  > background-images 大小固定，不會像 `<img>` 可隨螢幕大小伸縮。[註1]\n\n### 缺點\n\n- 在中斷點以上會有很多空白 leave a lot of empty space when viewed at higher resolutions\n\n- 固定寬度很難讓所有內容顯示在小尺寸的裝置 It can also be difficult to fit everything into the smaller screen real estate of a fixed width layout.3 columns can seem very tight at 800p.\n\n\n![](/assets/images/2022-04-04-16-11-38.png)\n\n> 圖源: [3 Popular Types of Web Design LayoutsSEPTEMBER 11, 2017 by CRYSTAL MATEO](https://linkage.ph/3-popular-types-web-design-layouts/)\n\n## 流動設計 Liquid Designs\n\n### 優點\n\n- 排版會填滿畫面，不會有空白 layout will adjust to fill a variety of resolutions. work well at both low and high resolutions without all the empty space outside of the design.\n\n- 使用 `rem`[註2] 或 `%` 而不是 `px`，讓眼睛不好的人可以更簡單的調整字體大小 A liquid layout with it's use of 'em' or percents instead of pixels will be more accessible to viewers with poor eyesight as they can more easily resize the text. It can also be easier to fit all of your content into the design for those viewers with higher resolution monitors.\n\n### 缺點\n\n- 寬度太寬導致一行字太長、難以閱讀 line length growing to wide which will make you text difficult to read.\n\n- 可以使用 `max-width` 解決太寬問題，但 IE 要用別的方式要特別注意一下 (這個感覺用 pollyfill 就可以解決) Using max-width is an option for browsers outside of Internet Explorer.IE will need it's own workaround to keep your lines of text from becoming too wide. A liquid layout can often be more difficult and time consuming to develop and test.\n\n![](/assets/images/2022-04-04-16-12-25.png)\n\n> 圖源: [3 Popular Types of Web Design LayoutsSEPTEMBER 11, 2017 by CRYSTAL MATEO](https://linkage.ph/3-popular-types-web-design-layouts/)\n\n\n## 半流動:混合式 Semi-Liquid: A Hybrid Approach\n\n在一個頁面裡，可以讓 header 在瀏覽器邊緣左右延伸 (stretch to the edges of the browser)，其他部分在視窗中心保持固定尺寸 (fixed size)。\n\n> The third design option is the hybrid approach where certain parts of the page are fixed and there's enough liquidity in other elements to keep the whitespace from looking too empty.\n\n\n半流動網頁可以在特定尺存讓排版流動 (fluid)。\n\n> semi-liquid design where the site will be fluid within a given range of resolutions\n\n舉例:一個網站設計了 800x600 的尺寸、並以流動方式排版放大到 1600×1200 為止，\n1600×1200 之後更大的尺寸網站保持在視窗中心，超過設計範圍的地方就空白。\n\n> The site for example might be designed to work at a minimum 800×600 resolution and expand fluidly until it reaches some upper maximum resolution such as 1600×1200. For larger resolutions the site remains in the center of the browser window and space is created outside the design。\n\n如此就可解決流動排版 (fluid design) 尺寸太大時一行字太多、固定排版 (fixed design) 螢幕較小時空白太多的問題。\n\n## 作者建議\n\n固定排版 (fixed design): 如果需要精準控制尺寸。建議讓頁面置中，空白處才會平均。\n\n流動排版 (fluid design): 如果使用者使用多元的尺寸，特別是大尺寸。建議以 1024×768 著手設計、\n並確定更小或更大的尺寸看此來好不好。\n\n>  If you're constrained by time or need precise control over your design then a fixed layout is probably the way to go. If accessibility is more important or your visitors use a variety of resolutions, particularly higher resolutions, the liquid approach will most likely the better option. With fixed designs I highly recommend centering the overall page in the browser window to balance the empty space on both sides of the layout. With liquid designs I recommend designing the site to look it's best at the common 1024×768 resolution while making sure the site still looks good at lower and higher resolutions.\n\n作者傾向半流動或混合式 (semi-liquid or hybrid design)。也在這篇文章 (2016) 時說這種寫法應該會變成主流。\n\n> For my own site I'll be using the semi-liquid or hybrid design more and more where I can. I think it's a very good compromise and allows enough of the benefits of both fixed and liquid designs while minimizing the cons of each. suspect too that hybrid designs will become more common and popular with designers given the wide variety of monitor resolutions.\n\n---\n\n## 小結\n\n感覺固定排版 (fixed design) 就是 AWD 常用的方式、流動排版 (fluid design) 就是 RWD 常用的方式。\n\n固定排版 (fixed design): 最強調 Mobile-First 行動優先 (在 RWD 還沒如現在盛行前)。\n\n流動排版 (fluid design): RWD。\n\n這篇文章定義得很清楚:\n\n[行動網站傻傻搞不清？RWD響應式網站 vs AWD自適應式網站 by Nadine Li](https://medium.com/nadine-mase/the-different-about-responsive-website-design-adaptive-web-design-92712d2ba7ab)\n\n> ➜ 若網站的資訊量很大，並想使用者做很多事\n> 選擇 AWD 自適應式網站佳，因能客製化手機上的使用體驗。像是網路書店、購物商城…等。\n>\n> ➜ 若網站資訊量沒那麼多，也只希望使用者做很少事\n> 選擇 RWD 響應式方式佳，因維護起來最方便，也能讓視覺上有一致的體驗。像是品牌官網、小型的購物商城。\n\n**整個看完才發現混著用才聰明😓 一不小心又非黑即白思考了...**\n\n總之目前知道差別就好，分類出來比較好記憶 xD\n\n另外還是不太清楚 `px` 和字體大小和瀏覽器放大縮小百分比到底有什麼關係，要找時間補一下。\n\n---\n\n- 註一: 關於瀏覽器如何顯示圖片可以參考這一篇文章\n\n  [Optimising Largest Contentful Paint by Harry](https://csswizardry.com/2022/03/optimising-largest-contentful-paint/)\n\n  > The reason these resources (in this specific case, background images) are slow is because they aren't requested until the browser is ready to paint the DOM node that needs them.\n  > we can sidestep this issue by adding an invisible `<img />`.\n\n- 註二: 關於 em 與 rem 可參考這篇: (自己覺得用 `rem` 會比較方便控制+好記)\n\n  [實際展示 EM 與 REM 的差異 by 卡斯伯](https://www.hexschool.com/2016/01/02/2016-08-08-em-vs-rem/)\n","n":0.038}}},{"i":36,"$":{"0":{"v":"0320 JS 小知識(一)","n":0.577},"1":{"v":"\n## 遞增運算子(++)與遞減運算子(--)\n\n```javascript\nx++ ←→ x = x + 1\nx-- ←→ x = x - 1\n```\n\n## 前置運算(Pre Increment)\n\n```javascript\n┌─ x 加一後代入 y\n│    ↑\n↓  ┌───┐\ny = │ ++x; │→ x 代入 x+1 的結果\n    └───┘\n```\n\n前置運算(Pre Increment): 先計算後再給值，y 和 x 的值一致都是計算後的結果(x+1 的值)。\n\n## 後至運算(Post Increment)\n\n```javascript\n┌── y 代入 x 的值\n│        ↑\n│   ┌─ │ ──┐\n↓   │ ┌─┐   │\ny  = │ │ x│++;│\n     │ └─┘   │→ x 後代入 x+1 的結果\n     └─────┘\n```\n\n後至運算(Post Increment): 先給值後再計算，y 可以保留 x+1 之前的值，x 保留 x+1 的值。\n\n## 差別\n\n```javascript\n// Post Increment\nvar x = 3;\nvar y = x++;\nconsole.log(x); // 4\nconsole.log(y); // 3\nconsole.log(`上一號: ${y}，目前號碼: ${x}`); // 上一號: 3，目前號碼: 4\n\n// Pre Increment\nvar x = 3;\nvar y = ++x;\nconsole.log(x); // 4\nconsole.log(y); // 4\nconsole.log(`目前人數共 ${x}/${y}`); // 目前人數共 4/4\n```\n\n總之，\n\n++x 運算符號在前(Pre)，就先進行運算!\n\nx++ 運算符號在後(Post)，先附值到使用運算子的對象上(x)，再運算。\n","n":0.097}}},{"i":37,"$":{"0":{"v":"0208 Live Server 開啟 build 檔案","n":0.408},"1":{"v":"\n## 1. 直接資料夾開啟 index.html，會遇到一些問題:\n\n在 angular 的 index.html 預設是 `<base href=\"/\">`\n\n所以會以檔案資料夾目錄的位置打開(網址列會長這樣: `file:///C:/Users/xxx.../dist/apps/client/index.html`)\n\n如果想用 `<base href=\"./\">` 解決問題，若有設定路由會發現網址除了 server 根網址以外還多了路由，然後發生 404 錯誤...\n\n![](/assets/images/2022-02-08-17-00-24.png)\n\n另外，在瀏覽器上 es6 module 一定會遵循 CORS (參考文章:[ES6 模組匯入-林信良](https://www.ithome.com.tw/voice/132470))，所以如果直接用 `file:///C:/Users/xxx.../dist/apps/client/index.html` 開啟會出現這樣的錯誤:\n\n![](/assets/images/2022-02-08-17-18-04.png)\n\n![](/assets/images/2022-02-08-17-55-33.png)\n\n> Origin: null 是 null 的。😭\n\n## 2. 下載 Live Server\n\n![](/assets/images/2022-02-08-13-49-40.png)\n\n所以這時就可以用 vscode 的 [Live Server 擴充套件](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) 來解決 Origin 的問題。\n\n接著發現可以成功載入首頁，但是其他路由會 404...\n\n## 3. 使用 Live Server 但路由出問題:\n\n原因是瀏覽器把路由當成 http request 了。😭\n\n![](/assets/images/2022-02-08-18-04-09.png)\n\n於是為了解決這個問題，可以設定 HashLocationStrategy。\n\n```typescript\nproviders: [{provide: LocationStrategy, useClass: HashLocationStrategy},\n```\n\n## 4. 關於 Angular HashLocationStrategy\n\n- Angular 官網\n  [HashLocationStrategy](https://angular.tw/api/common/HashLocationStrategy)\n\n> A LocationStrategy used to configure the Location service to represent its state in the [hash fragment](https://en.wikipedia.org/wiki/URL#Syntax) of the browser's URL.\n> 此 LocationStrategy 用來配置 Location 服務，以便在瀏覽器 URL 的 [hash 片段](https://en.wikipedia.org/wiki/URL#Syntax)中表示其狀態。\n\n- URI fragment wiki 說明\n  [URI fragment](https://en.wikipedia.org/wiki/URI_fragment)\n\n> Fragments depend on the document MIME type and are evaluated by the client (web browser). Clients are not supposed to send URI fragments to servers when they retrieve a document, and without help from a local application (see below) fragments do not participate in HTTP redirections.\n\n所以看起來 fragments 可以解決網址被送到 server 的問題！🎉\n\n感覺設定成 HashLocationStrategy 只有好處沒有壞處的感覺(除了不常看到有網址會長這樣以外)。\n\n## 5. 小結:設定 HashLocationStrategy + live server\n\n以後要開啟 build 後的檔案，可以設定 HashLocationStrategy 然後再用 live server 開啟就 Ok 了。🎉\n","n":0.078}}},{"i":38,"$":{"0":{"v":"0107 PostCSS 和 Sass","n":0.5},"1":{"v":"\n## 1. 前言\n\n到底為什麼要用 PostCSS 和 Sass?\n\n本篇筆記目的在搞清楚 CSS 的定義，然後說明 PostCSS 和 Sass 的用途。\n\n## 2. 關於 CSS\n\n不免俗先來權威機構 [W3C](https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91%E8%81%94%E7%9B%9F) 的定義。\n\nhttps://www.w3.org/standards/webdesign/htmlcss\n\n> What is CSS?\n> CSS is the language for describing the presentation of Web pages, including colors, layout, and fonts. It allows one to adapt the presentation to different types of devices, such as large screens, small screens, or printers. CSS is independent of HTML and can be used with any XML-based markup language. The separation of HTML from CSS makes it easier to maintain sites, share style sheets across pages, and tailor pages to different environments. This is referred to as the separation of structure (or: content) from presentation.\n\n> CSS 是啥?\n> CSS 是一種描述網頁呈現外觀的語言，包括顏色、排版、字體。它能根據載體來調整不同的呈現類型，譬如大螢幕、小螢幕或印表機。\n> CSS 獨立於 HTML 而且可以搭配任何以 XML 為基礎(XML-based) 的標記語言。在 HTML 中將 CSS 區分出來可以更容易地維護一個網站、跨頁分享樣式表和將頁面適應(tailor)於不同環境。這個涉及呈現外觀(presentation)的分離結構(或: 內容)。\n\n感覺起來 CSS 就是拿來定義頁面的樣式的。那命名是還蠻貼切的: CSS (Cascading Style Sheets)，如瀑布般下落的樣式表單。\n\n### 2.1. CSS 版本\n\nhttps://zh.wikipedia.org/wiki/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8\n\n- CSS Level 1\n- CSS Level 2\n- CSS Level 3\n- CSS Level 4\n\n我就是從 CSS3 入門的! 動畫超有趣!🥰\n\n> CSS3 亦支援動畫（animation）及立體（preserved-3d）。 —— Wikipedia\n\n### 2.2. CSS Syntax (句法)\n\nhttps://www.w3schools.com/css/css_syntax.asp\n\n![](/assets/images/2022-01-07-22-52-32.png)\n\n> HTML 和 CSS 是建置網頁的核心技術。透過瀏覽器我們可以看到網頁，所以可以透過 [Can I use](https://caniuse.com/) 來確定某個 CSS 的屬性(property)能不能使用。\n\n### 2.3. CSS Specificity (權重)\n\n再次不免俗，MDN 權威定義: https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity\n\n> Specificity is the means by which browsers decide which CSS property values are the most relevant to an element and, therefore, will be applied. Specificity is based on the matching rules which are composed of different sorts of CSS selectors.\n\n> 權重讓瀏覽器決定哪個元素跟屬性最有相關，而最相關的會被賦予樣式。權重依照 CSS 選擇器的排序有一套專屬的比對規則。\n\n```markdown\n!important > inline style > ID > Class/psuedo-class/attribute > Element\n0, 0, 0, 0, 0\n```\n\n有些例外: :is() 和 :not() 不納入權重計算。\n\n跟 js 一樣，css 從前往後讀，相同權重越後面的會覆蓋前面的。\n\n以 HTML 巢狀結構來看，內層會繼承上層樣式，但是如果該元素有被指定樣式，則以自己層的樣式為優先。\n\n所以計算權重指的是 HTML 結構中同一層元素，以該元素的 CSS 選擇器(Selector) 來計算權重。\n\n![](/assets/images/2022-01-07-23-16-39.png)\n\n> 位數概念: 如圖，最上層位數最大。\n\nSelector 計算方式舉例:\n\n```markdown\nbody h3 a → 0,0,0,0,3\nbody>h3>a → 0,0,0,0,3\nbody h3.myClass a → 0,0,0,1,3\nbody h3.myClass::before → 0,0,0,2,2\nbody h3 a:hover→ 0,0,0,1,3\nbody h3 a[href^=\"https\"]→ 0,0,0,1,3\n```\n\n這樣看起來我已經好久沒有用過 ID 了，Class/psuedo-class/attribute、 Element 最常用。😳\n\n### 2.4. CSS 效能\n\n[writing-efficient-css-selectors by Harry](https://csswizardry.com/2011/09/writing-efficient-css-selectors/)\n\n使用哪種選擇器效能比較好?(由上而下月上面的 selector 方式越好):\n\n1. ID, e.g. `#header`\n2. Class, e.g. `.promo`\n3. Type, e.g. `div`\n4. Adjacent sibling, e.g. `h2 + p`\n5. Child, e.g. `li > ul`\n6. Descendant, e.g. `ul a`\n7. Universal, i.e. `*`\n8. Attribute, e.g. `[type=\"text\"]`\n9. Pseudo-classes/-elements, e.g. `a:hover`\n\n看起來就是選得越準確越好。\n\n[css-selector-performance by Steven Bradley](https://vanseodesign.com/css/css-selector-performance/)\n\n- Avoid Universal Rules:\n\n  避免用 `*` (全選很耗效能)。\n\n- Don't qualify ID Rules with tag names or classes:\n\n  不要把 ID 名命名為 tag 名或 class 名。\n\n- Don't qualify Class Rules with tag names\n\n  不要把 class 名命名為 tag 名。\n\n- Use the most specific category possible\n\n  用最明確的類別(指定的越準確效能越好)。\n\n- Avoid the descendant selector\n\n  避免 `ul li` 選，跟全選同概念，很耗效能。\n\n- Tag Category rules should never contain a child selector\n\n  tag 應該永不包含 child selector。\n\n  也就是說不建議這樣 `ul > li`。\n\n  有點難懂...應該跟 `*` 同概念，選越少越好?🙄\n\n- Question all usages of the child selector\n\n  所有的 `ul > li` 都要抱持懷疑，真的有必要這麼多層嗎?\n\n  感覺是可讀性和效能的取捨耶。\n\n- Rely on inheritance\n\n  請倚賴繼承。\n\n- Use scoped stylesheets\n\n  使用區域樣式表單。\n\n  寫 angular 就是都有使用 scoped stylesheets，每一個 conponent 都幫你切好好的一個 scope。\n\n## 3. Sass 和 PostCSS 跟 CSS 的關係\n\n根據上面的介紹，感覺 CSS 那麼多功能又深奧，到底為什麼還需要 Sass 和 PostCSS?\n\n來看一下各自的官網簡介:\n\n### 3.1. Sass\n\nhttps://sass-lang.com/\n\n> Sass is the most mature, stable, and powerful professional grade CSS extension language in the world.\n\n> Sass 是世上最成熟、穩定、強大的專家級 CSS 擴充語言。\n\n### 3.2. PostCSS\n\nhttps://postcss.org/\n\n> A tool for transforming CSS with JavaScript\n\n> 一個用 JavaScript 轉換 CSS 的工具。\n\n從字面上看起來它們都是幫助人們撰寫 CSS 的工具。\n\n接下來要來看它們如何幫助開發與其運作原理。\n\n## 4. Sass\n\n### 4.1. Sass 特點\n\n- CSS 兼容性 CSS Compatible\n\n  Sass 可以完全兼容 CSS 的所有版本。Sass 十分看重兼容性，所以可以無縫接軌到任何可用的 CSS library 上。\n  Sass is completely compatible with all versions of CSS. We take this compatibility seriously, so that you can seamlessly use any available CSS libraries.\n\n- 功能豐富 Feature Rich\n\n  Sass 自豪擁有比其他 CSS 擴充語言更多的功能和能力。Sass 核心團隊無止境的工作不只是為了維持還包含持續領先。\n  Sass boasts more features and abilities than any other CSS extension language out there. The Sass Core Team has worked endlessly to not only keep up, but stay ahead.\n\n- 成熟的 Mature\n\n  Sass 已經被支援 15 年了。\n  Sass has been actively supported for about 15 years by its loving Core Team.\n\n- 業界認可 Industry Approved\n  業界總是首選 Sass 作為 CSS 擴充語言。\n  Over and over again, the industry is choosing Sass as the premier CSS extension language.\n\n- 龐大社群 Large Community\n\n  Sass 被聯營企業、科技公司和上百位開發者共同支持與開發著。\n  Sass is actively supported and developed by a consortium of several tech companies and hundreds of developers.\n\n- 框架 Frameworks\n  有無數框架使用 Sass 建置而成。如 Compass、Bourbon、Susy...等。\n  There are an endless number of frameworks built with Sass. Compass, Bourbon, and Susy just to name a few.\n\n### 4.2. Sass 運作原理(如何變成 CSS)\n\nhttps://www.w3schools.com/sass/sass_intro.php\n\n瀏覽器看不懂 Sass 程式碼。因此，你會需要 Sass 預處理器將 Sass 程式碼轉換成標準的 CSS。\n\n這個過程稱為轉譯。所以你需要給轉譯器(一種程式) Sass 程式碼然後會得到 CSS 程式碼。\n\n小秘訣: 轉譯是一個取得一個語言的源碼然後將它轉變/轉譯成另一種語言。\n\n> A browser does not understand Sass code. Therefore, you will need a Sass pre-processor to convert Sass code into standard CSS.\n>\n> This process is called transpiling. So, you need to give a transpiler (some kind of program) some Sass code and then get some CSS code back.\n>\n> Tip: Transpiling is a term for taking a source code written in one language and transform/translate it into another language.\n\n## 5. PostCSS\n\n### 5.1. PostCSS 特點\n\n- Autoprefixer\n\n  ![](/assets/images/2022-01-17-15-15-09.png)\n\n  增加可讀性\n  從 Can I Use 的資料加入廠商前綴詞，[Autoprefixer](https://github.com/postcss/autoprefixer) 會使用目前人氣瀏覽器和屬性支持度來幫你加上前綴。\n  Increase code readability\n  Add vendor prefixes to CSS rules using values from Can I Use. Autoprefixer will use the data based on current browser popularity and property support to apply prefixes for you.\n\n  ```CSS\n  /* CSS input */\n  :fullscreen {\n  }\n\n  /* CSS output */\n  :-webkit-full-screen {\n  }\n  :-ms-fullscreen {\n  }\n  :fullscreen {\n  }\n  ```\n\n- 使用最新的 CSS 語法! Use tomorrow's CSS today!\n\n  [postcss-preset-env](https://github.com/csstools/postcss-preset-env) 讓你可以將現代 CSS 用 [cssdb](https://github.com/csstools/cssdb/blob/main/README.md) 根據你的目標瀏覽器或 runtime 環境來轉換成大多數瀏覽器可以懂、決定用哪種 polyfills 的 CSS。\n  PostCSS Preset Env, lets you convert modern CSS into something most browsers can understand, determining the polyfills you need based on your targeted browsers or runtime environments, using [cssdb](https://github.com/csstools/cssdb/blob/main/README.md).\n\n  ```CSS\n  /* CSS input */\n  body {\n      color: lch(53 105 40);\n  }\n\n  /* CSS output */\n  body {\n      color: rgb(250, 0, 4);\n  }\n\n  ```\n\n- CSS 模組 CSS Modules\n\n  全域 CSS 的盡頭\n  CSS 模組代表你不需要擔心命名太過通用，可以直接使用最具意義的命名。\n  The end of global CSS\n  CSS Modules means you never need to worry about your names being too generic, just use whatever makes the most sense.\n\n  ```CSS\n  /* CSS input */\n  .name {\n       color: gray;\n  }\n\n  /* CSS output */\n  .Logo__name__SVK0g {\n      color: gray;\n  }\n  ```\n\n- 避免錯誤 Avoid errors in your CSS\n\n  使用 [stylelint](https://github.com/stylelint/stylelint) 執行一致的常規並避免樣式表的錯誤。[stylelint](https://github.com/stylelint/stylelint) 是一個現代 CSS linter，支援最新的 CSS 語法，也支援如 SCSS 的 CSS-like 語法。\n  Enforce consistent conventions and avoid errors in your stylesheets with [stylelint](https://github.com/stylelint/stylelint), a modern CSS linter. It supports the latest CSS syntax, as well as CSS-like syntaxes, such as SCSS.\n\n### 5.2. PostCSS 運作原理(如何變成 CSS)\n\nhttps://www.youtube.com/watch?v=WhCXiEwdU1A\n\n> ![](/assets/images/2022-01-17-16-12-49.png)\n> 可以和 Sass、less 合用，或是如圖用 postCSS 的 plugin 功能取代 Sass 和 less。\n\nhttps://www.toptal.com/front-end/postcss-sass-new-play-date\n\n> PostCSS is all about plugins. PostCSS 就是 plugins。\n\nhttps://cythilya.github.io/2018/08/10/postcss/\n\n> Summer 大大的文章。\n\n## 小結\n\n我還是搞不懂 postCSS 和 Sass 的差別xD\n但是知道 postCSS 是需要什麼功能時才透過加入 plugin 來使用功能，\n而 Sass 是一開始整包就幫你準備好了，照用就好了。\n\n## 6. tailwindcss\n\nhttps://tailwindcss.com/\n\n> Rapidly build modern websites without ever leaving your HTML.\n> 不用離開 HTML 就可以建置現代網頁。\n\n---\n\n## 7. Angular 相關\n\n以下是 Angular 應用 css 套件的相關文章。\n\nhttps://angular.tw/guide/component-styles\n\n## 8. Angular 已經有 Autoprefixer 了\n\n[Autoprefixer](https://angular.tw/guide/build#configuring-browser-compatibility)\n\n## 9. PurgeCSS with Angular\n\nhttps://dev.to/dylanvdmerwe/reduce-angular-style-size-using-purgecss-to-remove-unused-styles-3b2k\n\n## 10. webpack Loaders\n\n> sass-loader、postcss-loader\n\nhttps://stackoverflow.com/questions/59715916/how-to-use-sass-loader-in-angular\n\n## 11. tailwindcss with Angular\n\nhttps://hsuchihting.github.io/TailwindCSS/20210702/3640682418/\n\nhttps://medium.com/@JedChou/%E5%A6%82%E4%BD%95%E5%9C%A8-angular-%E5%B0%88%E6%A1%88%E4%B8%AD%E4%BD%BF%E7%94%A8-tailwind-css-e119b6390803\n\n## 12. Nx for Angular and tailwind\n\nhttps://nx.dev/angular/setup-tailwind\n\n先下載 tailwind\n\n```bash\nnpm install tailwindcss@latest postcss@latest autoprefixer@latest\n```\n\n選擇 .scss\n\n```javascript\n@import \"tailwindcss/base\";\n@import \"tailwindcss/components\";\n@import \"tailwindcss/utilities\";\n```\n\nhttps://nx.dev/guides/using-tailwind-css-in-react#step-1-install-tailwind-dependencies\n\nnpm install stylelint-config-recommended --save-dev\n\n13 版後 tailwind.config.js 會放置在 app 裡，預設只會\n\n```javascript\nmodule.exports = {\n  content: [\n    join(__dirname, 'src/**/*.{html,ts}'),\n    ...createGlobPatternsForDependencies(__dirname),\n  ],\n  //...\n};\n```\n","n":0.031}}},{"i":39,"$":{"0":{"v":"2021","n":1}}},{"i":40,"$":{"0":{"v":"1227 從 Nx 入門 monorepo","n":0.447},"1":{"v":"\n## 前言\n\n> 注意: 此篇文章撰寫時間 Nx 版本為 12，跟目前版本可能有些不一。 (Nx 版號會跟 Angular 版號一樣)\n\n使用 Nx Console 實現一個 Monorepo 架構的專案。\n\n導讀影片: [Monorepos - How the Pros Scale Huge Software Projects // Turborepo vs Nx](https://www.youtube.com/watch?v=9iU_IE6vnJ8)\n\n## 1. 簡介 Monorepo 架構\n\nMonorepo (全名 Monolithic Repository)，符合以下三個條件:\n\n1. **一個 repo** One Repository\n2. **多個 projects** Multiple projects (三個 app 加上兩個 libs 共 5 個專案)\n3. **共用 libs** Shared Libraries\n\n如下圖，這就是一個 Monorepo:\n\n![MonoRepo](/assets/images/2021-12-27-22-50-05.png)\n\nMonorepo 架構的主要目的是希望**集中管理套件版本**。\n\n只管理**一個** `package.json`，好處是套件版本管理方便、壞處是一個 repo 有多個 projects，檔案容易變非常大，讓 git 版控軟體跑起來較吃力。\n\n另外 Monorepo 讓 apps 之間共用 libs 變得方便簡單，所以可以降低重複程式碼的機率。\n也可以讓 Lerna、yarn 等套件管理工具更方便的減少重複的套件安裝。\n\n以 Nx 來說，還有個酷酷的特色:可以在同一個 repo 裡同時使用 react 和 angular 共同開發一個 app。\n\n雖然也可以使用 rollupjs 來達到不同前端框架共同開發一個 app 的效果。\n\n但 Nx 就像 monorepo 全家桶: 提供一個 Nx workspace 讓你的 monorepo 開發更容易。\n\n接下來，在看 Nx 怎麼使用之前，先來一些先備知識。\n\n## 2. 簡介 Nx 工具與專有名詞解釋\n\n### 2-1. 什麼是 Nx ?\n\n官網: https://nx.dev/\n\n![](/assets/images/2021-12-27-23-55-50.png)\n\n> 聰明、可擴充的建置框架，Nx 幫助任何規模的架構、測試、建置。\n> (Smart, Extensible Build Framework Nx helps architect, test, build at any scale:)\n\n- 以現代框架進行整合。(integrations with modern frameworks)\n- 計算快取。(computation caching)\n- 聰明的重新建置被修改過的專案。(smart rebuilds of affected projects)\n- 分散式任務執行。(distributed task execution)\n- 強大的程式碼產生器。(powerful code generators)\n- 支援 VSCode 和 WebStorm 編輯器。(editor support (VSCode, WebStorm))\n- (GitHub apps)\n- 還有更多。(and more.)\n\n**簡單來說就是: 可以用 Nx 提供的架構去整合程式碼。**\n\n### 2-2. Nx 的製作團隊\n\nnarwhal 簡寫 Nrwl，是獨角鯨的英文。\n\n![](/assets/images/2021-12-27-23-57-12.png)\n\n顧問、工程、訓練。\nConsulting. Engineering. Training.\n\nNrwl 創立於 2016 12 月，以 Angular 團隊成員、多位前 Google 員工、Jeff Cross、Victor Savkin 所組成。\n\n如今已有 18 位左右成員 (在美國、加拿大和英國)。\n\nNrwl 也是開源開發工具們的製作者: 給 monorepo 開發用的 Nx、和 Angular Console。\n\nNrwl was founded in December 2016 by Angular team members and former Googlers, Jeff Cross and Victor Savkin, and today has around 18 team members in the US, Canada and UK.\nNrwl is also the creator of open-source dev tools: Nx for monorepo development, and Angular Console.\n\n**簡單來說 Nrwl 就是一間科技公司 (Narwhal Technologies Inc.)**\n\n### 2-3. Angular monorepo patterns\n\n這本書說明了 nx 是如何實踐 monerepo 概念。\n\n![](/assets/images/2021-12-27-23-59-52.png)\n\n- https://connect.nrwl.io/app/books\n- https://nrwl.io/products\n\n### 2-4. Nx 與 Angular 淵源不淺\n\n![](/assets/images/2021-12-28-00-06-48.png)\n\n> 截圖自 [Monorepos - How the Pros Scale Huge Software Projects // Turborepo vs Nx](https://www.youtube.com/watch?v=9iU_IE6vnJ8)\n\n上面這兩位 Nx 開發的主導者是 Google 的前員工，且對 Angular 都有相當深入的理解。\n但 Nx 官網上有不少 react 的開發教學，如果有公司想要從 react 轉到 angular(或是 angular 轉 react 為主)，\n感覺透過 Nx 的幫助可以慢慢地移花接木(不然 Nx 也至少可以讓這兩框架和平共處)。😆\n\n### 2-5. Angular 詞彙表\n\n基本上只要知道 Angular 的詞彙就看得懂 Nx 在幹麻了，以下詞彙是在 Nx 也會看到的(取自 Angular 官網):\n\n- [Workspace](https://angular.tw/guide/glossary#workspace) (工作區)\n\n  一個 Angular 所有專案的集合(可以用 Angular CLI 操作這個集合)，通常會在 git 版本控制的 repository 中。\n\n- [Project](https://angular.tw/guide/glossary#project) (專案)\n\n  可以通過 Angular CLI 命令創建或修改的獨立應用程式或函式庫。可在 angular.json 中配置 workspace 中的所有 projects。\n\n- [Library](https://angular.tw/guide/glossary#library) (函式庫)\n\n  一種 Angular 專案。用來讓其它 Angular 應用包含它，以提供各種功能。函式庫不是一個完整的 Angular 應用，不能獨立執行。\n\n- [TypeScript 配置](https://angular.tw/guide/typescript-configuration#configuration-files)\n\n  一個 Angular 工作區中包含多個 TypeScript 配置檔案。在 root，有兩個主要的 TypeScript 配置檔案：tsconfig.json 檔案和 tsconfig.app.json 檔案。[使用 extends 進行配置繼承](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#tsconfig-bases)。\n\n- [Schematic](https://angular.tw/guide/glossary#schematic) (原理圖)\n\n  Angular CLI 使用原理圖來產生和修改 Angular 專案及其部件。\n\n- Collection (集合)\n\n  在 Angular 中，是指收錄在同一個 [npm 套件](https://angular.tw/guide/glossary#npm-package) 中的一組原理圖（schematics）。\n\n  ![](/assets/images/2021-12-28-00-23-52.png)\n\n### 2-6. Nx 名詞解釋\n\nNx 的 `[plugin]:[generator-name]` 就是 Angular 的 `[collections]:[schematic]`\n\n以下紀錄這個在 Nx 的說明與使用方式:\n\n- Generators (產生器)\n  產生器提供了一種方法，來自動執行您在開發工作流程中，經常執行的許多任務。\n  在 Nx 中，可以使用 `@nrwl/devkit` 或 `@angular-devkit` ，來製作產生器。\n  使用 `@angular-devkit` 製作的稱為 schematics (原理圖)。\n\n  下圖為 Nx 官網的 sidebar 的一小部分截圖，可以看見 Generator 有不少篇幅介紹。\n\n  ![](/assets/images/2021-12-28-21-51-09.png)\n\n### 2-7. Nx 的 Generators 的使用方式\n\n**Nx 的 `[plugin]:[generator-name]` 就是 Angular 的 `[collections]:[schematic]`。**\n\n所以有用 angular 寫過 schematic 的人有福了，可以更快上手 Nx 的 generator。🎉\n\n以下是關於如何調用 gnerator 的內容(截自 Nx 官網):\n\n- 調用插件產生器 [Invoking Plugin Generators](https://nx.dev/l/a/generators/using-schematics#invoking-plugin-generators)\n\n  產生器可以讓你以簡單和可重複的方式新增修改程式碼。可以使用 `nx generate` 指令來調用 (invoked) 產生器。\n  Generators allow you to create or modify your codebase in a simple and repeatable way. Generators are invoked using the nx generate command.\n\n  ```cmd\n  nx generate [plugin]:[generator-name] [options]\n  nx generate @nrwl/angular:component mycmp --project=myapp\n  ```\n\n  在使用產生器前有一個乾淨的 git 工作路徑很重要，因為這樣你能輕易的還原變動 (revert changes)、並使用不一樣的設定來重新調用產生器。\n  It is important to have a clean git working directory before invoking a generator so that you can easily revert changes and re-invoke the generator with different inputs.\n\n### 2-8. 小補充: 關於 collection 為何都是「＠xxx/ooo」這樣命名?\n\n這是 npm 的命名規則，詳情可以參考 npm 官網影片: [Working with npm private modules\n](https://www.youtube.com/watch?v=O6JoXGnHK_Y)\n\n> ＠後的字稱為 `@scope`，通常是 npm 的帳號名字(尤其要 publish 到 npm 上的話，就是 `@username` 的意思。)\n\n![](/assets/images/2021-12-28-21-53-15.png)\n\n## 3. 感受一下 Nx 的 monorepo 專案\n\n- Angular workspace 的 libs 通常都會有一個自己的 `package.json`\n\n  ![](/assets/images/2021-12-28-00-24-21.png)\n\n- Nx workspace 預設共用一個 `package.json`\n\n  ![](/assets/images/2021-12-28-00-28-00.png)\n\n### 3-1. 產生一個 Nx 的 workspace\n\n可以直接參考 npm 的說明:\n\nhttps://www.npmjs.com/package/create-nx-workspace\n\n![](/assets/images/2021-12-28-21-48-43.png)\n\n> Nx 12 提供的樣板。\n\n或是看官方 youtube 教學:\n\n[Nx in 100 seconds: Setup a new Nx workspace using its presets](https://youtu.be/XVJIXcC-7Kc)\n\n### 3-2. Nx 的 workspace 圖示\n\n除了圖示裡的這些，Nx workspace 也可以用來整合開發其他框架(最後面會補充)。\n\n![](/assets/images/2021-12-28-22-18-03.png)\n\n> 從靜態網頁框架、後端 nodejs 框架、前端框架到網站建置工具和最基礎的 js、html、css 都可以用 Nx 架構來整合\n\n## 4. 快速上手 Nx Console 操作 (Generate、Run)\n\n### 4-1. Nx Console 簡介\n\nNx 有提供一個介面讓人**可以用點按方式去執行指令**，就不用硬背一堆指令了，\n\n以下是關於這個套件的一些知識，\n\n因為這個介面有幫指令做分類，\n\n這邊特別有在 4-2 ~ 4-4 的地方對 nx generate 和 nx run 這兩個介面分類做了更深入的說明，\n\n首先，會先說明 Nx Console 是什麼? 並看看介面有什麼?:\n\n- Nx Console 套件安裝\n\n  - [Install from the VS Code Marketplace](https://marketplace.visualstudio.com/items?itemName=nrwl.angular-console)\n  - [Contribute on GitHub](https://github.com/nrwl/nx-console)\n\n- Nx Console 前生今世\n\n  `Nx Console` 前生為 `Angular Console`，詳情可以看這篇文章:\n  https://blog.nrwl.io/re-introducing-nx-console-a21fa9f4f668\n\n  `Angular Console` 是一個桌面應用程式 (Desktop App)。\n\n  最一開始是以 `Electron` 在開發，後來 `Angular Console` 團隊將桌面應用程式移植到 VS Code 的擴充套件上。結果發現效能很糟...\n\n  所以他們就決定打掉重練： 以 VS Code 套件提供的基底重新開發一個擴充套件，\n\n  並且順帶將套件重新命名為 `Nx Console`。\n\n  `Nx Console` 包括 `Angular Console` 和 `Nx` 的功能，最後連 `Nx` 和 `Angular Console` 的製作團隊也整併再一起了。\n\n  ![](/assets/images/2021-12-28-22-21-50.png)\n\n- Nx 套件教學\n\n  如果不小心跳過一開始的新手教學，可以到 github 看，`Nx Console` 套件的也是以 `Nx 架構` 寫成的。😎\n\n  https://github.com/nrwl/nx-console/tree/master/apps/vscode/src/getting-started\n\n- Nx Console 官網主打口號\n\n  - Nx 專用的純 UI 介面。(True UI for Nx)\n  - 專家和初學皆適用。(Useful for both experts and beginners)\n  - 豐富的文件說明。(Documentation)\n\n- 介面分三個區塊\n\n  - Generate & Run Target\n    開發專案時常用到的指令。等等下面會講一下 `Generate` 和 `Run`。\n  - Common Nx Commands\n    關於被修改過的檔案會有一些功能可以用，另外還有產生專案相依狀態的圖表、依次執行多個指令的指令可以用。\n  - Projects\n    這裡就是圖示化 `angular.json` 的 `projects` 區塊，可以直接按按鈕執行 script。\n\n    ![](/assets/images/2021-12-28-22-35-51.png)\n\n### 4-2. nx generate (常見的 collection)\n\n> 這裡是 2-6、2-7 定義的應用，如果看不懂可以往回看。\n\n當你按下 `Generate` 的按鈕時，就會幫你執行 `nx generate`，並根據 `generator` (`schematic`) 產生預期的結果。\n以下列出常見的 collection:\n\n1. `@angular/cdk`\n2. `@angular/material`\n\n   以上兩個都是 Angular Material 相關 collection。\n\n   ![](/assets/images/2021-12-28-22-53-23.png)\n\n3. `@nrwl/storybook`\n\n   Storybook 相關 collection。\n\n4. `@nrwl/angular`\n\n   Nx cli 預設的 collection (1)。\n\n5. `@nrwl/workspace`\n\n   Nx cli 預設的 collection (2)。\n\n6. `@schematics/angular`\n\n   Angular cli 預設的 collection。\n\n### 4-3. 產生 Library 有三個 schematic 可以用\n\n- `@schematics/angular`\n\n  ![](/assets/images/2021-12-28-22-58-21.png)\n\n- `@nrwl/angular`\n\n  ![](/assets/images/2021-12-28-22-59-05.png)\n\n  ![](/assets/images/2021-12-28-23-00-04.png)\n\n  ![](/assets/images/2021-12-28-23-00-23.png)\n\n- `@nrwl/workspace`\n\n  ![](/assets/images/2021-12-28-22-59-20.png)\n\n* collection 偵測方式 (node_module/ 全部偵測):\n\n  https://github.com/nrwl/nx-console/blob/ad3578a1a2/libs/server/src/lib/utils/read-collections.ts\n\n* vscode-angular-schematics collection 偵測方式:\n\n  https://github.com/cyrilletuzi/vscode-angular-schematics/blob/main/src/defaults.ts\n\n### 4-4. nx run\n\n同時 build 所有 projects 內有 build script 的專案。\n\n`nx run-many --target=build --all --parallel`\n\n![](/assets/images/2021-12-28-23-01-03.png)\n\n- https://angular.tw/cli/run\n- https://nx.dev/l/a/cli/run-many\n\n## 5. 其他補充\n\n### 5-1. 常見的 Monorepo 架構開發工具\n\n![](/assets/images/2021-12-28-23-03-34.png)\n\n還有更多工具: https://github.com/korfuri/awesome-monorepo\n\n### 5-2. 誤解: Nx 和 Yarn Workspace/Lerna 只能擇一使用?\n\nhttps://nx.dev/l/n/guides/lerna-and-nx#clarifying-misconceptions\n\n![](/assets/images/2021-12-28-23-05-05.png)\n\n功能沒有重疊，Nx 不是 package manager 也不是 JS-only 的工具。可一起用。\n\n![](/assets/images/2021-12-28-23-05-31.png)\n\nNx 官方 youtube 頻道相關影片\n\n- [How to Migrate From Lerna to Nx](https://www.youtube.com/watch?v=Edv7ZeI8Bwc)\n- [Lerna/Yarn to Nx: Faster Build Times + Better Dev Ergonomics](https://www.youtube.com/watch?v=BO1rwynFBLM)\n\n### 5-3. 查看有哪些 Nx plugin 可以使用\n\n`nx list`\n\n或到官網查看列表:\nhttps://nx.dev/community#community-plugin-list\n\n### 5-4. Nx 13\n\n![](/assets/images/2021-12-28-23-07-16.png)\n\nWebpack 5 Module Federation Plugin\n\n- https://nx.dev/l/a/guides/setup-mfe-with-angular\n- Micro Frontends with Angular using Module Federation - Manfred Steyer\n\n### 5-5. Nx 學習資源\n\n- Nx 官網\n\n  https://nx.dev/\n\n- Nx Console for VSCode 介紹\n\n  https://nx.dev/latest/angular/getting-started/console#nx-console-for-vscode\n\n- Github 上用 Nx + Angular 星星數最多的專案 Angular Spotify by Trung Vo\n\n  https://github.com/trungk18/angular-spotify\n\n- Angular Spotify 作者專訪 youtube\n\n  https://youtu.be/w04CfqZI8Xo\n\n- Nx Conf 連結 (2021/9/16-2021/9/17)\n\n  https://youtu.be/oG2QbFquraA\n\n  https://www.youtube.com/watch?v=hlGOaGDsWKg\n\n- 書\n\n  https://connect.nrwl.io/app/books\n\n  https://nrwl.io/products\n","n":0.034}}},{"i":41,"$":{"0":{"v":"1226 使用 Dendron 紀錄","n":0.5},"1":{"v":"\n## 使用 Dendron 紀錄\n\n### Dendron 簡介\n\n筆記都可以方便被記錄，但取出筆記又是一大學問。\n\nDendron 主打方便取出筆記 (get notes back out)。\n作者 [Kevin](https://www.dendron.so/about) 說道 Dendron 有以下三特點:\n\n- [Note Reference](https://wiki.dendron.so/notes/f1af56bb-db27-47ae-8406-61a98de6c78c/)\n- [Commands](https://wiki.dendron.so/notes/eea2b078-1acc-4071-a14e-18299fc28f47/#refactor-hierarchy)\n- [Lookup](https://wiki.dendron.so/notes/a7c3a810-28c8-4b47-96a6-8156b1524af3/)\n\n總之，寫筆記可以變得像在寫程式，可以加入「參考」，如果「參考」不存在，還可以幫你新增一個對應的空白參考。\n\n檔案分類以資料夾檔名分類，每篇筆記會有一個獨一無二的 id，同時一個 id 會有一個 title (文章標題)。\n\n當使用者想將文章移去其他分類時只要改檔名就好，檔名命名邏輯以「.」分層，第一層.第二層.第三層... 以此類推。\n\n另外還有 Note Graph 的功能 `ctrl+shift+P`、`Dendron: Show Note Graph` 就可以看到整個 vault 的結構 (下圖為我目前的 Note Graph)。\n\n![](/assets/images/2022-01-01-13-19-20.png)\n\n[綱要(Schemas)](https://wiki.dendron.so/notes/c5e5adde-5459-409b-b34d-a0d75cbb1052/) 是用 YAML 來為筆記設定基礎樣板。\n\n支援 [mermaid-js](https://mermaid-js.github.io/mermaid/#/)。\n\n另外 Dendron 提供了不少 [組織(Organizing)](https://wiki.dendron.so/notes/BWYKFQ8297OgfWWyV7Bgn/) 筆記的功能 (Tags 就是其中一種)，另外也有給團隊使用的組織方式。\n\n![](/assets/images/2022-01-01-13-41-23.png)\n\n> 有這麼多組織(Organizing)的方式...(水好深)。🤤\n\n另外 Dendron 還可以部署到 Github Pages 上，詳情請參閱官網: [Dendron to Github Pages](https://wiki.dendron.so/notes/yg3EL1x9fEe4NMqxUC3jP/)。\n\n下載 `Dendron CLI` 後可以將筆記轉成資料、並套上 `Next.js` 的部落格樣板，`git push` 到 github 上做些設定就可以看到部落格了。🎉\n\n所以 `Next.js` 的使用者有福了!可以用熟悉的網頁框架客製化自己的部落格。\n\n謝謝 Dendron 作者們讓菜雞如我可以接觸 `Next.js`。😆\n\n### 撰寫文章\n\n選擇在欲要新增文章的 parent .md 檔上，`Dendron: Lookup (Ctrl+L / Cmd+L) `，輸入檔名就可以開始寫新筆記了。\n\n### 建置並預覽筆記\n\n- **Preview**\n\n  `npx dendron publish dev`\n\n  http://localhost:3000 在本機查看網站，`Crtl+C` 離開終端機。\n\n- **Publish**\n\n  `npx dendron publish export --target github`\n\n  以 target github 輸出網站。\n\n參考資料:\nhttps://wiki.dendron.so/notes/yg3EL1x9fEe4NMqxUC3jP/\n\n---\n\n### .next 專案 fork 來源\n\nhttps://github.com/dendronhq/nextjs-template\n\n---\n\n## 問題紀錄\n\n### github page build 失敗\n\n```bash\n  /usr/bin/git submodule sync\n  Error: fatal: No url found for submodule path '.next' in .gitmodules\n```\n\n![](/assets/images/2021-12-31-19-23-24.png)\n\n解答: https://stackoverflow.com/questions/4185365/no-submodule-mapping-found-in-gitmodule-for-a-path-thats-not-a-submodule\n\n- 問題起因: `git submodule update --init` 發生 No submodule mapping found in .gitmodules 問題。\n\n  覺得應該是一開始我 `git init` 時，忘記先將 .next 排除版控 `echo .next >> .gitignore`。\n\n  造成 .git 版控出了一些問題 (.next 自己也有一個 .git 版控)，執行下面的指令後就好了。\n\n- `git rm --cached .next`\n\n  [git 官網參數說明](https://git-scm.com/docs/git-rm)\n\n  ```bash\n  --cached\n  Use this option to unstage and remove paths only from the index.\n  Working tree files, whether modified or not, will be left alone.\n  ```\n\n  取消追蹤 .next 資料夾版控後，github page build 就可以順利完成 github page 的 build 了。 😄\n\n### npx dendron publish dev ctrl+c 以後 port 沒有清掉\n\n`netstat -a` 查看使用中連線。\n\n`npx kill-port 3000` 清除 3000 port。\n\n參考網址: https://stackoverflow.com/questions/39632667/how-do-i-kill-the-process-currently-using-a-port-on-localhost-in-windows\n\n### 加入 Disqus 留言板\n\n參考資料:\n\n- [Integrating Disqus in your Next.js React Application by Imran Sayed](https://imranhsayed.medium.com/disqus-is-a-networked-community-platform-used-by-hundreds-of-thousands-of-sites-all-over-the-web-39b88bafaca5)\n- [如何安裝 Disqus 留言板](https://ithelp.ithome.com.tw/articles/10242269)\n\n### 為標題編號\n\n下載 vscode 套件 [markdown all in one](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one)\n\n`shift + ctrl + P` 輸入 number 然後選這個，就會自動編號了。\n\n![](/assets/images/2022-02-08-18-31-50.png)\n","n":0.064}}},{"i":42,"$":{"0":{"v":"pending notes","n":0.707}}},{"i":43,"$":{"0":{"v":"2023","n":1}}},{"i":44,"$":{"0":{"v":"0116 [Angular] onChange 還是 get set 好","n":0.378}}},{"i":45,"$":{"0":{"v":"2022","n":1}}},{"i":46,"$":{"0":{"v":"1129 Nand2tetris","n":0.707},"1":{"v":"\n## 前言\n\n真的很想知道記憶體超頻那些數字到底是在調什麼... 第三章 Memory 有提到記憶體的運作方式，來看看能不能開竅...\n\n絕對要配這個看:\n\n[Nand2Tetris 慕課記 -- 從邏輯閘到方塊遊戲 by 陳鍾誠老師](https://programmermagazine.github.io/mag/ymag201506/book.html)\n\n課程章節:\n\n```\n0. From Nand to Tetris\n1. Boolean Functions\n2. Boolean Arithmetic\n3. Memory\n4. Machine Language\n5. Computer Architecture\n6. Assembler\n7. VM I: Stack Arithmetic\n8. VM II: Program Control\n9. High-Level Language Project\n10. Compiler I: Syntax Analysis Project\n11. Compiler II: Code Generation Project\n12. Operating System\n```\n\n### 網路公開課 Build a Modern Computer from First Principles\n\n就是這兩堂課:\n\n![](/assets/images/2022-11-29-11-32-17.png)\n\n- [Build a Modern Computer from First Principles: From Nand to Tetris (Project-Centered Course) by Shimon Schocken, Noam Nisan](https://www.coursera.org/learn/build-a-computer)\n\n- [Build a Modern Computer from First Principles: Nand to Tetris Part II (project-centered course) by Shimon Schocken](https://www.coursera.org/learn/nand2tetris2)\n\n### [Nand2tetris 網站](http://nand2tetris.org/)\n\n![](/assets/images/2022-11-29-11-37-00.png)\n\n> 可以前往下載講義/簡報/習題\n\n## 筆記處\n\n## 小結\n","n":0.103}}},{"i":47,"$":{"0":{"v":"1115-[Angular] 日期","n":0.707},"1":{"v":"\n\n// providers: [{ provide: MAT_DATE_LOCALE, useValue: 'zh-TW' }],\n","n":0.354}}},{"i":48,"$":{"0":{"v":"0920 [Angular] 從 Change Detection 到 ngZone","n":0.378}}},{"i":49,"$":{"0":{"v":"0919-[Angular] 驗證與共用元件","n":0.707},"1":{"v":"\n<!-- title: tag0418-2021-表單驗證心得記錄\ndate: 2021-04-18 18:24:14\ncategories: 學習日記 -->\n\n關於共用表單頁面、表單驗證的 ui 的一些想法...\n\n<!-- more -->\n\n## 共用元件\n\n通常新增和編輯的頁面會需要共用\n\n### 法 1: 蒐集資料用的表單(包含打 api 功能)\n\n##### 📌 新增時\n\n1. 要給 api 用的資料會要在共用元件裡蒐集起來，打 api\n\n##### 📌 編輯時\n\n1. 要先在編輯頁打 api 拿到資料 input 到共用元件\n2. 給 api 用的資料會要在共用元件裡蒐集起來，打 api\n   (編輯比新增多一步驟)\n\n新增頁面和編輯頁面的送出按鈕都會寫在共用元件裡，\n這樣需要多 input 一個參數來看現在是在編輯狀態還是新增狀態，\n然後打 api 會跟著按鈕走，所以打新增和修改的 api 的動作會寫在共用元件裡...\n\n所以共用元件除了欄位驗證邏輯會寫裡面，還要 input 狀態進去判斷現在是要新增還編輯，還要根據狀態打不同的 api\n那這樣拆成新增編輯 component 就只是為了 routing 比較方便了\n\n### 法 2: ReactiveForm 同步雙向綁定\n\n如果我是用 ReactiveForm 做共用元件的話就可以把按鈕放到各自新增和編輯的 component、也可以各自注入 service 打 api\n這樣共用元件的功能就單純很多: 欄位驗證、蒐集資料、角色判斷、控制欄位 disable\n不用幫畫面的按鈕做狀態判斷是否顯示\n然後打 API 前的資料的檢查(轉成字串、是否要吃使用者輸入的資料還是寫死)就是在各自的 component 裡判斷、注入 api 的 service\n**相對法 1 ，法 2 可以讓共用元件更專注在驗證邏輯和資料的邏輯(就不用去在意 input 和新增編輯狀態的管理)**\n所以我從頭到尾只用在意輸入的資料，完全不用去管什麼時候要 input output、 input output 的值變化後什麼時候被什麼事件觸發去改變值\n我只要輸入資料，資料就在共用元件裡經過驗證，並根據傳入的資料做介面的變化\n其他打 api 的動作也拆出去在共用元件以外的地方做，讓共用元件真的就只用做 ui 與資料驗證的控制就好\n\n所以我是比較喜歡用 ReactiveForm 來做共用元件 xD\n\n#### 法 2 demo\n\n[⚡stackblitz ReactiveForm 共用元件](https://stackblitz.com/edit/angular-ivy-qaqscf?file=src/app/app.component.ts)\n\n> 此 demo 參考自 [Building Reusable Forms in Angular - Cory Rylan](https://coryrylan.com/blog/building-reusable-forms-in-angular)\n\n#### 參考資料\n\n[[功能介紹-10] Reactive Forms (Model-Driven Forms)](https://ithelp.ithome.com.tw/articles/10195280)\n\n---\n\n## 欄位驗證\n\n[Angular Forms: Useful Tips - Armen Vardanyan](https://indepth.dev/posts/1224/angular-forms-useful-tips)\n\n> Forms are not type-safe\n\n- 可以使用 Pipes 做 ui 顯示轉換的處理\n- 可以使用 Directives 做表單的驗證處理\n\n### 欄位驗證的方式\n\n- 只能輸入...: 只能輸入中英、只能輸入英文、只能輸入數字、只能輸入特定幾個字\n  => 直接讓使用者不能敲除了規定以外的字就不用做錯誤提示了!(使用者在輸入時將不符合規定的都置換成空字串'')\n\n- 限制字數\n  => 使用 html `<input type=\"text\">` 的 `maxlength` 去限制字數\n  不要用 `type=\"number\"` 不然沒辦法精準控制輸入的字數...\n\n- 錯誤提示: 達到特定條件要提示錯誤，如. 必須大於 0、起訖日有誤\n  => 用 (input) 和 (change) 去綁事件判斷不符合條件時 formControl 要 setErrors() 並加入 html 提示\n  可以將事件方法和錯誤 dom 抽出來寫成 directive\n\n#### 錯誤題示 directive demo\n\n[⚡stackblitz 將錯誤題示寫成 directive](https://stackblitz.com/edit/angular-ivy-bsunxe?file=src/app/app.component.html)\n","n":0.077}}},{"i":50,"$":{"0":{"v":"0914 [Ch2Ch3]IO、OS 架構、VM","n":0.577},"1":{"v":"\n## IO 運作方式: Interrupt 介紹、HW Resource protection\n\n### I/O 運作方式\n\n#### polling I/O (programmed I/O)\n  \nDef: 又叫 Busy waiting I/O 或 programmed I/O\n\n步驟如下:\n\n1. 執行中的 Process，發出 I/O request 給 OS 希望 OS 提供某種 I/O 服務，eg Disk read a file。\n2. OS 收到請求後(可能)會先暫停(block)該 process 即此 process 會放 CPU 至於 waiting queue 等待 I/O completed。\n3. OS (or Kernel) 中的 I/O-subsystem 會處理此請求。eg 也會檢查 Disk cache 是否有命中，若有剛從 Disk cache 取出 file 資料 不用 read I/O。\n4. I/O-subsystem 會 pass 此請求給 device driver(驅動程式)。\n   driver -( request I/O subsystem )-> OS\n5. device driver 會依此請求設定相關 I/O commands 到 device controller(硬體)。\n6. device controller  會指揮 I/O-device 執行 I/O 運作\n7. 此時 CPU 可能 idle，OS 可能會將 CPU 分派給其他 process 使用。\n   [怎麼知道設備到底完成了沒有?]\n8. CPU 會不斷地去 polling I/O-device controller 上之相關 registers 值，確定 I/O 運作完成與否或有無 error。\n \n缺點: 本希望 CPU 專心 process，但 CPU 並未將全 time 用於此 process exec 上而是耗費大量時間去 polling IO-device controllers。\n所以 CPU utilization 不高，且 process throughput 偏低。\n\n```mermaid\nflowchart TD\n    B[device driver 驅動程式] -->|設定相關 I/O-commands| C\n    C[device controller 硬體] -->|指揮 I/O-device 執行 I/O 運作| D[I/O-device]\n    B ---->|interface| E[OS subsystem - I/O subsystem]\n    E ---->|register| B\n```\n\n```mermaid\nflowchart TD\n    A[CPU] -->|cpu idle 分派給其他程序使用| E[7 Process B 看電視]\n    A[CPU] --> B\n    B[Process A 看書 - 2 blocked] -->|1 發出 I/O 請求| C\n    C[3 kernal - I/O subsystem] -->|4 pass| D\n    D[device driver] -->|5 I/O 命令| F[6 I/O decvice 硬體 - 好了不會通知]\n    A ---->|8 polling - CPU 要一直檢查好了沒| F\n```\n\n#### Interrupted I/O\n\n8. 當 I/O 運作完成，I/O-device controller 會發出一個 \"I/O-completed\" interrupt 通知 CPU(OS)\n9. OS 收到中斷通知後(可能)會先暫停目前執行中的 process(eg. PB execution -> ready state)\n10. OS 會依 Interrupt ID(No) 查詢 Interrupt vector(表) 找出中斷對應的服務處理程式(ISR: interrupt service routine) 之位址。\n11. Jump to ISR 位址，ISR 執行(eg. 將 File Data 從 Controller 之 buffer registers 搬到 memory 中)\n12. ISR 完成，控制權交回 kernel I/O-subsystem 通知 process 其 I/O completed 以及告知結果。\n13. OS 恢復中斷之前 process 的執行(eg Process B exec) 或交由 cpu schedule 決定下一執行之 process。\n\n\n```mermaid\nflowchart TD\n    A[CPU] -->|cpu idle 分派給其他程序使用| E[7 Process B 看電視 - executed]\n    A[CPU] --> B\n    B[Process A 看書 - 2 blocked] -->|1 發出 I/O 請求| C\n    C[3 kernal - I/O subsystem - ISR] -->|4 pass| D\n    D[device driver] -->|5 I/O 命令| F[6 I/O decvice 硬體]\n    F ---->|8 發出 I/O-completed intterupt 到 OS 以通知 CPU I/O 已完成| C\n    E ---->|9 I/O 完成| G[Process B - ready]\n    C -->|10 根據 Interrupt ID 查中斷向量表 11 找到對應 ISR 並執行| C\n    F -->|11 ISR 執行需 CPU 參與 譬如將 I/O-device buffer 搬到 memory 之中| F\n    B -->|12 OS 通知 I/O-completed| H[Process A - ready]\n```\n\n優點: \n\nCPU 無需花費時間用於 polling I/O device controller，而是可以全心用於 Process 之 execution 上。所以 CPU utilization 較高， throughput 相對地較高故 improve the system performance。\n\n缺點: \n\n* Interrupt 之處理仍需耗費 cpu time (eg 查表.執行 ISR 保存中斷前 process 之 state etc)\n* \n\n#### DMA\n\n#### Interrupt 之處理\n\nDef: DMA controller 負責 I/O-Device 與 memory 之間的 Data transfer 工作。此 transfer 過程不須 cpu 參與。\n\n所以 CPU 有更多時間用於 process exec 上。\n另外 DMA 適合用在 block-transfer oriented I/O Device。例如 Disk。\nnote: 可以降低 I/O completed 中斷頻率。不適合 Byte transfer oriented、character transfer oriente。\n\n缺點: 引入 DMA controller 必須與 CPU 競爭 memory 及 bus 使用權。(需有一硬體協調設計機制，此技術叫 interleaving 或 cycle stealing)\n\n有時 cpu 會被迫等待 DMA when it make use of memory bus.\n\nmachine instruction cycle \n\n``` baah\n  抓指令    解碼     執行     x轉存器，記憶體抓   write back\n|   IF   |   DE   |   EXE   |        MEM        |     WB    | :storage\n   必須     不用      不用          可能            可能      :是否要去 memory access\n  有衝突     無       無           無/有           無/有     :DMA目前在使用 memory/也要用\n```\nir 指令暫存器 \nalu ← signal 通知\n\n當 conflict 時，通常給 DMA 高優先權。\n\n理由: DMA 對 memory、bus 上使用頻率低於 cpu 很多，優先配給 DMA (給需求量少的人)會有比較小的平均 waiting time 及較高之產出(throughput)。\n\n\n\n\n#### 種類\n\n### Interrupt 介紹\n\n#### HW Resource Protection\n\n#### 基礎\n\n##### Daul mode 運作\n\n##### privileged instructions\n\n#### I/O\n\n#### memory\n\n#### cpu","n":0.043}}},{"i":51,"$":{"0":{"v":"0109-TypeScript(未完)","n":1},"1":{"v":"\n## 編譯器\n","n":0.707}}},{"i":52,"$":{"0":{"v":"0101 Server建置與管理","n":0.707},"1":{"v":"\n\n\n## 前言\n\n打算伺服器入門一下。\n\n策略: 入門先求廣，這篇筆記會記錄我讀這本書的每章節主旨，看完之後找到有興趣或不懂的地方再開坑深挖。\n\n## 書名: [MIS 一定要懂的伺服器建置與管理知識](https://www.books.com.tw/products/0010807048)\n\n作者: きはし まさひろ | 譯者： 陳禹豪, 黃瑋婷 | 出版社：旗標\n\n共八章節。\n\n## Ch01 【序章】\n\n- 定義 Server: 對企業內部或網際網路上的用戶端(Client)提供各種服務的電腦。\n- 用戶端和伺服器之間的關係: 由伺服器和用戶端架構而成的系統就稱為「用戶端/伺服器系統(Client/Server System)，或稱為主從式架構」，是網路世界最常見的服務架構。\n- Server 會提供不同服務，所謂的伺服器其實就是一部安裝了「伺服器軟體」的電腦，不同的伺服器軟體提供不同的服務。\n- 因應各種需求而生伺服器功能:\n\n## Ch02 【伺服器管理者必備的網路基礎知識】\n\nOSI 參考模型及通訊協定 / 交換 (Switching) 技術 / IP 和 IP 位址 / 路由 (Routing) / ARP 協定 / TCP 和 UDP 協定 / NAT 和 NAPT\n\n## Ch03 【從七大面向建立架設前置知識】\n\nOn-premise / 雲端 / 混合雲 / IaaS / PaaS / SaaS / 資料中心 / 虛擬化 / 即時移轉 / 容錯系統 / Host OS 型態 / Hypervisor 型態 / 直立式 (Tower) / 機架式 (Rack) / 刀鋒式 (Blade)\n\n## Ch04 【企業內部的伺服器】\n\nDHCP 伺服器 / 位址池 / DNS 伺服器 / 工作群組 / AD 網域 / 網域主控站 / 檔案伺服器 / NAS / 列印伺服器 / SSO 伺服器 / SSO 代理型 / SSO 反向代理型 / MFA 多重驗證 / SIP 伺服器 / Proxy 伺服器 / SMTP 伺服器 / POP3 伺服器 / SMTP AUTH / POP before SMTP / MS Exchange Server / Exchange Online / 私有雲\n\n## Ch05 【對外營運的伺服器】\n\n網頁伺服器 / Apache / IIS / SSL 伺服器 / 數位憑證 / 對稱金鑰加密 / 公開金鑰加密 / FTP 伺服器 / 網頁應用程式伺服器 / Java EE / .NET Framework / 資料庫伺服器 / RDBMS / VPN 伺服器 / IPSec VPN / SSL-VPN\n\n## Ch06 【預防伺服器發生故障】\n\nRAID1 / RAID5 / RAID0+1 / Teaming / 容錯 / 叢集 / 儲存共享架構 / 資料鏡像架構 / 伺服器負載平衡技術 / 廣域負載平衡技術 / UPS\n\n## Ch07 【伺服器的資安防護】\n\n傳統式防火牆 / UTM 整合式威脅管理設備 / NGFW 次世代防火牆 / WAF 網頁應用程式防火牆 / SQL 注入攻擊 / 跨網站指令碼 (XSS) / 跨網站偽造請求 (CSRF) / Security Zone / Untrust Zone / DMZ / Trust Zone / IDS 與 IPS\n\n## Ch08 【伺服器的維運管理】\n\n遠端管控 / SSH / 系統更新及 Bug 修復 / WSUS 伺服器 / 備份與還原 / ipconfig 等常用指令 / NTP 伺服器 / Syslog 伺服器 / SNMP 伺服器\n\n## 小結\n","n":0.061}}}]}
